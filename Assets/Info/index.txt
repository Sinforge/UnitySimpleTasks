Темы для подготовки к экзамену по дисциплине «Моделирование сред и разработка приложений дополненной и виртуальной реальности» для студентов 3 курса. Форма обучения: Очная.  






Исполнитель
	Вопросы??
	Анатолий 😈
	1 - 12
	Артем
	13-24
	Алексей🏇🏇🏇
	25-36
	Ольга
	37-48
	Виталий
	49-60
	Владислав 
	61-72
	Semen
	73-84
	Иоанн
	85-95
	Islam
	96-100
	

________________




1 Позиционирование игровых объектов.
Позиционирование игровых объектов
Во время создания игры, вы должны разместить много различных объектов в вашем игровом мире.
Перемещение, вращение и масштабирование
Используйте инструменты трансформаций в панели инструментов для перемещения, вращения и масштабирования отдельных объектов. Каждый инструмент имеет соответствующее гизмо, которое появляется вокруг выделенного игрового объекта в окне Scene. Вы можете использовать мышь и манипулировать любой осью гизмо для изменения компонента Transform игрового объекта, или Вы можете ввести значения непосредственно в числовые поля компонента в инспекторе. Каждый из трех режимов может быть выбран горячими клавишами - W для перемещения, E для вращения и R для масштабирования.
  

2 Local/Global система координат в чем отличие?
(ChatGPT)
В Unity3D существуют две системы координат: локальная (local) и глобальная (world). Они используются для определения положения объектов в пространстве и имеют важные отличия:
Локальная система координат (Local)
Центр: Локальная система координат имеет центр в средней точке объекта.
Отсчет: Координаты объекта отсчитываются относительно центра объекта.
Поведение: Локальные координаты изменяются при изменении положения объекта в пространстве.
Глобальная система координат (World)
Центр: Глобальная система координат имеет центр в начале координатного пространства.
Отсчет: Координаты объекта отсчитываются относительно начала координатного пространства.
Поведение: Глобальные координаты не изменяются при изменении положения объекта в пространстве, они остаются постоянными.
В целом, локальные координаты используются для описания положения объекта относительно его центра, а глобальные координаты — для описания положения объекта в пространстве в целом.
3 Редактирование свойств.
Properties(свойства) - параметры и опций компонентов, которые можно редактировать в инспекторе.
  

Так, компонент Light отображает различные значения и свойства-ссылки.
Свойства можно широко разделить на категории ссылки (связи с другими объектами и ассетами) или величины (числа, флажки, цвета и т.д.).
Ссылки
Ссылки могут быть назначены путём перетягивания объекта или ассета подходящего типа на соответствующий пункт в инспекторе. Например, компоненту Mesh Filter надо сослаться на ассет Mesh где-то в этом проекте. Когда компонент только создан, ссылка ещё не назначена:
  

Значения
Большинство значений редактируются с помощью знакомых текстовых полей, флажков и меню, в зависимости от их типа (для удобства, числовые значения можно увеличивать и уменьшать, двигая мышью вверх и вниз зажав кнопку мыши на названии опции). Тем не менее, есть некоторые значения более сложных типов, которые имеют свои специфические редакторы. Они описаны ниже.
4 Игровые объекты в Unity.
В Unity3D GameObjects — это основные объекты, которые используются для создания и организации элементов в приложении или игре. Они могут содержать различные части, называемые Компонентами, которые определяют поведение и внешний вид объекта. GameObjects могут быть использованы для создания персонажей, объектов, светов, звуков и других элементов, которые составляют игру или приложение.
5 Теги в Unity.
Метка (Tag) — это ссылочное слово, которое можно присвоить одному или более GameObject. Например, вы можете определить метки "Игрок" для управляемых персонажей и "Враг" для не управляемых персонажей. Вы можете определить объекты, которые игрок может собрать в сцене, с меткой "Собирать". Вы можете использовать любое слово, которое вам понравится, как метку. даже короткие фразы, но вам может потребоваться расширение Инспектора для просмотра полного имени метки. Каждый GameObject может иметь только одну метку, присвоенную к нему.
Метки помогают вам идентифицировать GameObject для целей программирования. Они обеспечивают, что вам не нужно вручную добавлять GameObject в свойства скрипта с помощью перетаскивания, что позволяет вам экономить время при использовании одного и того же кода скрипта в нескольких GameObject.
Метки полезны для триггеров в сценариях контроля Коллайдера, которые должны определить, взаимодействует ли игрок с врагом, предметом или собирать, например.
!!! Игровому объекту может быть назначен только один тег.
  

6 Традиционный игровой ввод.
Unity поддерживает ввод с клавиатуры, джойстика и гейпада.
Виртуальные оси и кнопки могут быть созданы в Input Manager, и конечные пользователи смогут настраивать ввод с клавиатуры на экране конфигурационного диалогового окна.
Из скриптов все виртуальные оси доступны по их именам.
Каждый проект при создании содержит следующие оси ввода по умолчанию:
* Horizontal и Vertical привязаны к w, a, s, d и клавишам направления.
* Fire1, Fire2, Fire3 привязаны к клавишам Control, Option (Alt) и Command соответственно.
* Mouse X и Mouse Y привязаны к перемещениям мыши.
* Window Shake X и Window Shake Y привязаны к перемещению окна.
7 Ввод\вывод на мобильном устройстве.
На мобильных устройствах класс Input предоставляет доступ к нажатию на экран, акселерометру и географическим/локационным данным.
Доступ к клавиатуре на мобильных устройствах обеспечивается через iOS keyboard.
Multi-Touch Screen
iPhone и iPod способны отслеживать до пяти нажатий на экран одновременно. Вы можете получить статус каждого нажатия на протяжении последнего кадра через массив Input.touches.
Android устройства не имеют определенного лимита на количество нажатий, которое можно отслеживать. Он колеблется от устройства к устройству и может варьироваться от одного-двух нажатий на старых устройствах, до пяти нажатий на некоторых новых.
________________


Для ввода данных с клавиатуры на мобильном устройстве можно использовать Input.GetKeyDown(KeyCode) или Input.touches для работы с сенсорным вводом.
Для вывода информации на экран мобильного устройства в Unity можно использовать функции отрисовки, такие как GUI или UI. Можно также использовать текстовые поля или специальные элементы интерфейса для вывода информации.
8 Источники света, принцип работы, типы.
Вы можете использовать свойство Type, чтобы выбрать поведение источника света. Доступны следующие значения:
* point light - источник света, расположенный в определенной точке сцены и излучающий свет во всех направлениях одинаково
* spot light - источник света, расположенный в определенной точке сцены и излучающий свет в форме конуса
* Направленный свет (Directional Lights) - источник света, расположенный бесконечно далеко и излучающий свет только в одном направлении
* Area Lights - источник света, который определяется прямоугольником или диском в сцене и равномерно излучает свет во всех направлениях по всей площади поверхности, но только с одной стороны прямоугольника или диска
Point Lights
Точечный источник света расположен в определенной точке пространства и равномерно рассеивает свет во всех направлениях. Направление света, падающего на поверхность, - это линия от точки контакта обратно к центру объекта освещения. Интенсивность уменьшается с удалением от источника света, достигая нуля в указанном диапазоне. Интенсивность света обратно пропорциональна квадрату расстояния от источника. Это известно как ‘закон обратных квадратов’ и похоже на то, как свет ведет себя в реальном мире.
  

Spot Lights
Как и точечный источник света, точечный источник света имеет определенное местоположение и диапазон, в пределах которого свет гаснет. Однако точечный источник света ограничен углом, в результате чего получается область освещения в форме конуса. Центр конуса направлен в прямом направлении (Z) объекта освещения. Свет также уменьшается по краям конуса точечного источника света. Увеличение угла увеличивает ширину конуса, а вместе с ним и размер этого затухания, известного как ‘полутень’
  

Направленное освещение
Направленный свет полезен для создания таких эффектов, как солнечный свет в ваших сценах. Во многом подобно солнцу, направленный свет можно рассматривать как удаленные источники света, которые находятся бесконечно далеко. Направленный источник света не имеет определенного положения, поэтому объект освещения может быть размещен в любом месте сцены. Все объекты в сцене освещаются так, как будто свет всегда исходит с одного и того же направления. Расстояние источника света от целевого объекта не определено, и поэтому свет не уменьшается.
  

Area Lights
Вы можете определить Area Light с помощью одной из двух фигур в пространстве: прямоугольника или диска. Area Light излучает свет с одной стороны этой формы. Излучаемый свет равномерно распространяется во всех направлениях по площади поверхности этой формы. Свойство Range определяет размер этой фигуры. Интенсивность освещения, обеспечиваемого Area Light, уменьшается со скоростью, определяемой обратным квадратом расстояния от источника света (см. закон обратных квадратов). Поскольку этот расчет освещения требует значительных ресурсов процессора, Area Lights недоступны во время выполнения и могут быть встроены только в карты освещения.
  



9 Работа с анимацией в Unity.
Система анимации Unity основана на концепции Анимационных Клипов, которые содержат информацию о том, как определенные объекты должны изменять свое положение, вращение или другие свойства со временем. Каждый клип можно рассматривать как отдельную линейную запись. Анимационные клипы из внешних источников создаются художниками или аниматорами с помощью сторонних инструментов, таких как Autodesk® 3ds Max® или Autodesk® Maya®, или поступают из студий захвата движения или других источников.
Затем Анимационные Клипы организуются в структурированную систему, похожую на диаграмму потока, называемую Контроллером Аниматора. Контроллер Аниматора действует как "Машина Состояний", которая отслеживает, какой клип должен в данный момент воспроизводиться, и когда анимации должны изменяться или смешиваться.
Очень простой Контроллер Аниматора может содержать всего один или два клипа, например, для управления вращением и отскоком бонуса или для анимации открытия и закрытия двери в нужное время. Более продвинутый Контроллер Аниматора может содержать десятки анимаций человекоподобного персонажа для всех действий основного персонажа и может смешивать несколько клипов одновременно для плавного движения персонажа по сцене.
Система Анимации Unity также имеет множество специальных функций для работы с человекоподобными персонажами, которые позволяют перенаправлять анимацию человекоподобных персонажей из любого источника (например, захват движения; магазин активов; или другая сторонняя библиотека анимации) на вашу собственную модель персонажа, а также настраивать определения мышц. Эти специальные функции включены в систему Аватаров Unity, где человекоподобные персонажи отображаются в общем внутреннем формате.
Каждый из этих элементов - Анимационные Клипы, Контроллер Аниматора и Аватар, объединены на GameObject через компонент Animator. Этот компонент имеет ссылку на Контроллер Аниматора и (при необходимости) Аватар для этой модели. Контроллер Аниматора, в свою очередь, содержит ссылки на используемые им Анимационные Клипы.
10 Обзор и инструменты скриптинга.
Поведение игровых объектов контролируется с помощью компонентов (Components), которые присоединяются к ним. Несмотря на то, что встроенные компоненты Unity могут быть очень разносторонними, вскоре вы обнаружите, что вам нужно выйти за пределы их возможностей, чтобы реализовать ваши собственные особенности геймплея. Unity позволяет вам создавать свои компоненты, используя скрипты. Они позволяют активировать игровые события, изменять параметры компонентов, и отвечать на ввод пользователя каким вам угодно способом.
Unity изначально поддерживает два языка программирования:
* C# (произносится как Си-шарп), стандартный в отрасли язык подобный Java или C++;
* UnityScript, язык, разработанный специально для использования в Unity по образцу JavaScript;
Скрипт взаимодействует с внутренними механизмами Unity за счет создания класса, наследованного от встроенного класса, называемого MonoBehaviour. Вы можете думать о классе как о своего рода плане для создания нового типа компонента, который может быть прикреплен к игровому объекту. Каждый раз, когда вы присоединяете скриптовый компонент к игровому объекту, создается новый экземпляр объекта, определенный планом. Имя класса берется из имени, которое вы указали при создании файла. Имя класса и имя файла должны быть одинаковыми, для того, чтобы скриптовый компонент мог быть присоединен к игровому объекту.
Основные вещи, достойные внимания, это две функции, определенные внутри класса. Функция Update - это место для размещения кода, который будет обрабатывать обновление кадра для игрового объекта. Это может быть движение, срабатывание действий и ответная реакция на ввод пользователя, в основном всё, что должно быть обработано с течением времени во игровом процессе. Чтобы позволить функции Update выполнять свою работу, часто бывает полезно инициализировать переменные, считать свойства и осуществить связь с другими игровыми объектами до того, как будут совершены какие-либо действия. Функция Start будет вызвана Unity до начала игрового процесса (т.е. до первого вызова функции Update), и это идеальное место для выполнения инициализации.
________________


Из инструментов стоит отметить:
Окно Консоли (меню: Окно > Консоль) показывает ошибки, предупреждения и другие сообщения, генерируемые Unity. Для облегчения отладки вы также можете отображать свои собственные сообщения в консоли с помощью Debug.Log, Debug.LogWarning и Debug.LogError функции.
Панель инструментов окна консоли имеет ряд опций, влияющих на способ отображения сообщений.
________________


Другие инструменты: формирование лог-файлов, Editor Test Runner (тестирование)
11 Управление игровыми объектами (GameObjects) с помощью компонентов.
В редакторе Unity вы изменяете свойства Компонента используя окно Inspector. Так, например, изменения позиции компонента Transform приведет к изменению позиции игрового объекта. Аналогично, вы можете изменить цвет материала компонента Renderer или массу твёрдого тела (RigidBody) с соответствующим влиянием на отображение или поведение игрового объекта. По большей части скрипты также изменяют свойства компонентов для управления игровыми объектами. Разница, однако, в том, что скрипт может изменять значение свойства постепенно со временем или по получению ввода от пользователя. За счет изменения, создания и уничтожения объектов в заданное время может быть реализован любой игровой процесс.
Обращение к компонентам
Наиболее простым и распространенным является случай, когда скрипту необходимо обратиться к другим компонентам, присоединенных к тому же GameObject. Это делается с помощью функции GetComponent. Типично, объект компонента сохраняют в переменную, это делается в C# посредством следующего синтаксиса:
void Start () {
    Rigidbody rb = GetComponent<Rigidbody>();
}
	

Как только у вас есть ссылка на экземпляр компонента, вы можете устанавливать значения его свойств, тех же, которые вы можете изменить в окне Inspector:
void Start () {
    Rigidbody rb = GetComponent<Rigidbody>();


    // Change the mass of the object's Rigidbody.
    rb.mass = 10f;
}
	Если вы попытаетесь извлечь Компонент, который не был добавлен к Игровому Объекту, тогда GetComponent вернет null; возникнет ошибка пустой ссылки при выполнении (null reference error at runtime), если вы попытаетесь изменить какие-либо значения у пустого объекта.
Обращение к другим объектам
Пусть иногда они и существуют изолированно, все же, обычно, скрипты отслеживают другие объекты. Например, преследующий враг должен знать позицию игрока. Unity предоставляет несколько путей получения других объектов, каждый подходит для конкретной ситуации.
Самый простой способ найти нужный игровой объект - добавить в скрипт переменную типа GameObject с уровнем доступа public:
public class Enemy : MonoBehaviour {
    public GameObject player;


    // Other variables and functions...
}
	Нахождение дочерних объектов
Иногда игровая сцена может использовать несколько объектов одного типа, таких как враги, путевые точки и препятствия. Может возникнуть необходимость отслеживания их в определенном скрипте, который управляет или реагирует на них (например, все путевые точки могут потребоваться для скрипта поиска пути). Чаще всего удобно управлять набором объектов, сделав их дочерними одного родительского объекта. Дочерние объекты могут быть получены, используя компонент Transform родителя (так как все игровые объекты неявно содержат Transform):
using UnityEngine;


public class WaypointManager : MonoBehaviour {
    public Transform[] waypoints;


    void Start() {
        waypoints = new Transform[transform.childCount];
        int i = 0;


        foreach (Transform t in transform) {
            waypoints[i++] = t;
        }
    }
}
	Вы можете также найти заданный дочерний объект по имени, используя функцию Transform.Find:
transform.Find("Gun");
	Это может быть полезно, когда объект содержит дочерний элемент, который может быть добавлен или удален в игровом процессе. Хороший пример - оружие, которое может быть подобрано и выброшено.
Нахождение объектов по имени или тегу
Нахождение игровых объектов в любом месте иерархии доступно всегда, когда у вас есть некоторая информация, по которой их можно идентифицировать. Отдельные объекты могут быть получены по имени, используя функцию GameObject.Find:
GameObject player;


void Start() {
    player = GameObject.Find("MainHeroCharacter");
}
	Объект или коллекция объектов могут быть также найдены по их тегу, используя функции GameObject.FindWithTag и GameObject.FindGameObjectsWithTag:
GameObject player;
GameObject[] enemies;


void Start() {
    player = GameObject.FindWithTag("Player");
    enemies = GameObject.FindGameObjectsWithTag("Enemy");
}
	12 Функции событий в Unity.
Скрипт в Unity не похож на традиционную идею программы, где код работает постоянно в цикле, пока не завершит свою задачу. Вместо этого, Unity периодически передаёт управление скрипту при вызове определённых объявленных в нём функций. Как только функция завершает исполнение, управление возвращается обратно к Unity. Эти функции известны как функции событий, т.к. их активирует Unity в ответ на события, которые происходят в процессе игры. Unity использует схему именования, чтобы определить, какую функцию вызвать для определённого события. Например, вы уже видели функцию Update (вызывается перед сменой кадра) и функцию Start (вызывается прямо перед первым кадром объекта).
Обычные Update события
Update вызывается перед отрисовкой кадра и перед расчётом анимаций.




Физический движок также обновляется фиксированными по времени шагами, аналогично тому как работает отрисовка кадра. Отдельная функция события FixedUpdate вызывается прямо перед каждым обновлением физических данных. Т.к. обновление физики и кадра происходит не с одинаковой частотой, то вы получите более точные результаты от кода физики, если поместите его в функцию FixedUpdate, а не в Update.
Также иногда полезно иметь возможность внести дополнительные изменения в момент, когда у всех объектов в сцене отработали функции Update и FixedUpdate и рассчитались все анимации. В качестве примера, камера должна оставаться привязанной к целевому объекту; подстройка ориентации камеры должна производиться после того, как целевой объект сместился. Другим примером является ситуация, когда код скрипта должен переопределить эффект анимации (допустим, заставить голову персонажа повернуться к целевому объекту в сцене). В ситуациях такого рода можно использовать функцию LateUpdate.
События инициализации
Зачастую полезно иметь возможность вызвать код инициализации перед любыми обновлениями, происходящими во время игры. Функция Start вызывается до обновления первого кадра или физики объекта. Функция Awake вызывается для каждого объекта в сцене в момент загрузки сцены. Учтите, что хоть для разных объектов функции Start и Awake и вызываются в разном порядке, все Awake будут выполнены до вызова первого Start. Это значит, что код в функции Start может использовать всё, что было сделано в фазе Awake.
События GUI
В Unity есть система для отрисовки элементов управления GUI поверх всего происходящего в сцене и реагирования на клики по этим элементам. Этот код обрабатывается несколько иначе, нежели обычное обновление кадра, так что он должен быть помещён в функцию OnGUI, которая будет периодически вызываться.
void OnGUI() {
    GUI.Label(labelRect, "Game Over");
}
Вы также можете определять события мыши, которые срабатывают у GameObject’а, находящегося в сцене. Это можно использовать для наведения орудий или для отображения информации о персонаже под указателем курсора мыши. Существует набор функций событий OnMouseXXX (например, OnMouseOver, OnMouseDown), который позволяет скрипту реагировать на действия с мышью пользователя. Например, если кнопка мыши нажата в то время, когда курсор мыши находится над определённым объектом, то, если в скрипте этого объекта присутствует функция OnMouseDown, она будет вызвана.
События физики
Физический движок сообщит о столкновениях с объектом с помощью вызова функций событий в скрипте этого объекта. Функции OnCollisionEnter, OnCollisionStay и OnCollisionExit будут вызваны по началу, продолжению и завершению контакта. Соответствующие функции OnTriggerEnter, OnTriggerStay и OnTriggerExit будут вызваны когда коллайдер объекта настроен как Trigger (т.е. этот коллайдер просто определяет, что его что-то пересекает и не реагирует физически). Эти функции могут быть вызваны несколько раз подряд, если обнаружен более чем один контакт во время обновления физики, поэтому в функцию передаётся параметр, предоставляющий дополнительную информацию о столкновении (координаты, “личность” входящего объекта и т.д.).
13 Создание и уничтожение игровых объектов.
В Unity, игровой объект (GameObject) может быть создан используя функцию Instantiate, которая делает копию существующего объекта:


public GameObject enemy;
void Start() {
    for (int i = 0; i < 5; i++) {
        Instantiate(enemy);
    }
}
Заметьте, что объект с которого берется копия не обязан присутствовать на сцене. Гораздо чаще используется префаб, который был перетащен на открытую переменную (public variable) из файлов проекта в панели Project. Также, копируя игровой объект (GameObject), вы копируете все компоненты оригинального объекта.
Также есть функция Destroy, которая уничтожит объект после того, как загрузка кадра будет завершена или опционально после короткой паузы:


void OnCollisionEnter(Collision otherObj) {
    if (otherObj.gameObject.tag == "Missile") {
        Destroy(gameObject,.5f);
    }
}
Заметьте что функция Destroy может уничтожать отдельные компоненты без влияния на сам объект. Частая ошибка - писать что-то вроде этого:


 Destroy(this);
Что на самом деле уничтожит только вызывающий скриптовый компонент, вместо того, чтобы уничтожить игровой объект, к которому присоединен этот скрипт.
14 Создание и использование скриптов.
Поведение игровых объектов контролируется с помощью компонентов (Components), которые присоединяются к ним. Несмотря на то, что встроенные компоненты Unity могут быть очень разносторонними, вскоре вы обнаружите, что вам нужно выйти за пределы их возможностей, чтобы реализовать ваши собственные особенности геймплея. Unity позволяет вам создавать свои компоненты, используя скрипты. Они позволяют активировать игровые события, изменять параметры компонентов, и отвечать на ввод пользователя каким вам угодно способом.


Unity изначально поддерживает три языка программирования:
C# - стандартный в отрасли язык подобный Java или C++;
UnityScript, язык, разработанный специально для использования в Unity по образцу JavaScript;
В дополнение к этим, с Unity могут быть использованы многие другие языки семейства .NET, если они могут компилировать совместимые DLL


Создание скриптов
В отличии от других ассетов, скрипты обычно создаются непосредственно в Unity. Вы можете создать скрипт используя меню Create в левом верхнем углу панели Project или выбрав Assets > Create > C# Script (или JavaScript/Boo скрипт) в главном меню.
Новый скрипт будет создан в папке, которую вы выбрали в панели Project. Имя нового скрипта будет выделено, предлагая вам ввести новое имя.


Структура файла скрипта
После двойного щелчка на скрипте в Unity, он будет открыт в текстовом редакторе. По умолчанию Unity будет использовать MonoDevelop, но вы можете выбрать любой редактор из панели External Tools в настройках Unity.
Содержимое файла будет выглядеть примерно так:
using UnityEngine;
using System.Collections;


public class MainPlayer : MonoBehaviour {


    // Use this for initialization
    void Start () {
    
    }
    
    // Update is called once per frame
    void Update () {
    
    }
}
Скрипт взаимодействует с внутренними механизмами Unity за счет создания класса, наследованного от встроенного класса, называемого MonoBehaviour. Вы можете думать о классе как о своего рода плане для создания нового типа компонента, который может быть прикреплен к игровому объекту. Каждый раз, когда вы присоединяете скриптовый компонент к игровому объекту, создается новый экземпляр объекта, определенный планом. Имя класса берется из имени, которое вы указали при создании файла. Имя класса и имя файла должны быть одинаковыми, для того, чтобы скриптовый компонент мог быть присоединен к игровому объекту.


Основные вещи, достойные внимания, это две функции, определенные внутри класса. Функция Update - это место для размещения кода, который будет обрабатывать обновление кадра для игрового объекта. Это может быть движение, срабатывание действий и ответная реакция на ввод пользователя, в основном всё, что должно быть обработано с течением времени во игровом процессе. Чтобы позволить функции Update выполнять свою работу, часто бывает полезно инициализировать переменные, считать свойства и осуществить связь с другими игровыми объектами до того, как будут совершены какие-либо действия. Функция Start будет вызвана Unity до начала игрового процесса (т.е. до первого вызова функции Update), и это идеальное место для выполнения инициализации.


Управление игровым объектом
Как было сказано ранее, скрипт определяет только план компонента и, таким образом, никакой его код не будет активирован до тех пор, пока экземпляр скрипта не будет присоединен к игровому объекту. Вы можете прикрепить скрипт перетаскиванием ассета скрипта на игровой объект в панели Hierarchy или через окно Inspector выбранного игрового объекта. Имеется также подменю Scripts в меню Component, которое содержит все скрипты, доступные в проекте, включая те, которые вы создали сами.
После присоединения скрипт начнет работать, когда вы нажмете Play и запустите игру. 
15 Специальные папки и порядок компиляции скриптов.
По большей части, вы можете выбирать любые имена для папок вашего проекта. Однако в Unity зарезервированы некоторые имена, которые указывают на то, что содержащийся в папках контент имеет специальное назначение. Некоторые из них влияют на порядок компиляции скриптов (ниже представлены названия зарезервированных папок проекта) .
Assets
Editor
Editor default resources
Gizmos
Plugins
Resources
Standard Assets
StreamingAssets


 По сути, у компиляции скриптов есть четыре отдельные фазы и порядок их компилирования определяется родительской папкой.
Это имеет большое значение в случае, если скрипт должен обратится к классам, определенным в других скриптах. Основное правило заключается в том, чтобы не было ссылок на скрипты, компилирующиеся в фазе после. Все, что компилируется в текущей или ранее выполненной фазе, должно быть полностью доступно.
Другая ситуация бывает когда скрипт, написанный на одном языке, должен ссылаться на класс, определенный на другом языке(например, скрипт на языке UnityScript объявляет переменные класса, определенные в C# скрипте). В этом случае класс, на который ссылаются, должен быть скомпилирован в более ранней фазе.


Есть следующие фазы компиляции: 
Фаза 1: Выполняются скрипты из папок с именами Standard Assets, Pro Standard Assets и Plugins.
Фаза 2: Скрипты находящиеся в папках под названием Editor, которые находятся в любом месте внутри папок верхнего уровня, называемых Standard Assets, Pro Standard Assets и Plugins.
Фаза 3: Все прочие скрипты, не находящиеся в папке Editor.
Фаза 4: Все оставшиеся скрипты (т.е. находящиеся в папке Editor).


Дополнительно, любой скрипт, находящийся в папке WebPlayerTemplates, в самом верху папки Assets, вообще не будет скомпилирован. Это поведение немного отличается для вложенных папок с другими именами (например, Scripts/Editor работает как папка для скриптов редактора и Scripts/WebPlayerTemplates не помешает компиляции).
В общем случае, скрипт UnityScript ссылается на класс, определенный на языке C#. Здесь нужно разместить C# файл в папку Plugins, а UnityScript - в любую не специальную папку. Если этого не сделать, получите ошибку, говорящую о том, что C# класс не найден.
Note: Standard Assets работают только в корневой папке Assets 
16 Сетевая система Unity. (честно хз че писать там огромный пласт текста в доке, можете про фотон рассказать)
API высокого уровня (HLAPI) — это система создания многопользовательских возможностей для игр Unity. Он построен поверх нижнего уровня транспортного уровня связи в реальном времени и выполняет многие общие задачи, необходимые для многопользовательских игр. Хотя транспортный уровень поддерживает любую топологию сети, HLAPI является авторитетной серверной системой. Работая в сочетании с интернет-сервисами , это позволяет играть в многопользовательские игры через Интернет без особых усилий со стороны разработчиков.
HLAPI — это новый набор сетевых команд, встроенный в Unity, в новом пространстве имен: UnityEngine.Networking. Он ориентирован на простоту использования и итеративную разработку
Транспортный уровень поддерживает базовые службы сетевой связи. Эти базовые услуги включают в себя:
* Установление связей
* Общение с использованием разнообразия «качества услуг»
* Управление потоком
* Базовая статистика
* Дополнительные услуги, такие как связь через сервер ретрансляции или локальное обнаружение.
Транспортный уровень может использовать два протокола: UDP для общих коммуникаций и WebSockets для WebGL. Чтобы использовать транспортный уровень напрямую, типичный рабочий процесс будет следующим:


* Инициализируйте сетевой транспортный уровень
* Настройка топологии сети
* Создать хост
* Начать общение (обработка соединений и отправка/получение сообщений)
* Завершите работу библиотеки после использования.
Инициализация сетевого транспортного уровня
При инициализации сетевого транспортного уровня вы можете выбрать между инициализацией по умолчанию без аргументов или предоставить параметры, которые управляют общим поведением сетевого уровня, например максимальный размер пакета и ограничение времени ожидания потока.
Конфигурация
Следующий шаг — настройка соединения между пирами. Возможно, вы захотите определить несколько каналов связи, каждый с разным уровнем качества обслуживания, указанным в соответствии с конкретными типами сообщений, которые вы хотите отправлять, и их относительной важностью в вашей игре.
Топология
Последним шагом настройки сети является определение топологии. Топология сети определяет, сколько разрешенных соединений и какая конфигурация соединений будет использоваться
Создание хоста
После того, как все предварительные шаги выполнены, мы можем создать хост (открытый сокет)
Коммуникация
Когда хост создан, мы можем начать общение. Для этого мы отправляем на хост другую команду и проверяем ее статус.
17 Сборка VR проекта, особенности, существующие варианты реализации (тоже хз что здесь писать нигде про это нет).
Выберите целевое устройство
В зависимости от выбранного устройства будет строиться не только вся разработка, но и определяться размер аудитории продукта. Обычно VR игры в зависимости от устройства делят на 5 категорий:
● Легкий мобильный VR, такой как Google Cardboard и подобные решения
● Премиум Мобильный VR (Gear VR, Daydream и др.)
● PC VR-гарнитуры (Oculus Rift, HTC Vive, Windows Mixed Reality и др.)
● Автономные решения (Oculus Go, Oculus Quest)
● Консольный VR (Sony PlayStation VR)
Выбор игрового движка
Чаще всего при разработке игр для VR выбирать приходится между двумя стульями движками — Unity и Unreal Engine. Преимущества Unity:
● Unity хорош как для кросс-платформеных решений, так и для сложных проектов;
● Количество ассетов в Unity Asset Store в пять раз больше, чем в Unreal Engine Marketplace;
● Более крупное сообщество разработчиков.
Преимущества UE:
● Большее количество визуальных эффектов «из коробки»;
● Лучше подходит для крупных проектов ААА-уровня;
● Система Blueprints является отличным решением для новичков.




18 Контролеры персонажа, принцип работы, способы реализации.
Контроллер персонажа — это компонент, который позволяет объекту двигаться и взаимодействовать с коллайдерами. Именно контроллер отвечает, например, за передвижение по ступенькам, столкновение со стенами, попадание проджектайлов.
В Unity есть базовые контроллеры персонажей: built-in (Character Controller) и rigidbody. У каждого есть свои особенности, которые влияют на поведение в игре и взаимодействие с другими объектами. Также можно сделать кастомный контроллер, который будет работать именно так, как нужно разработчику.
Built-in контроллер по умолчанию присутствует в движке: он позволяет персонажу подниматься по ступеням, забираться по склону, ходить по неровным поверхностям и врезаться в стены. Вероятно, этот контроллер — самый простой и быстрый способ добавить передвижение в игру.
Другой контроллер — rigidbody: позволяет объектам взаимодействовать друг с другом по законам физики в реальном времени. Это значит, что на объекты будут оказывать влияние такие факторы как: гравитация, масса, инерция, лобовое сопротивление. У rigidbody-контроллера есть две версии, у каждой из которых есть свои особенности: kinematic и dynamic. На dynamic оказывают влияние другие физические объекты. Например, если в персонажа попадёт предмет, то его отбросит как и любой другой объект. А с kinematic-объектами такого не происходит — персонаж будет продолжать стоять, даже если в него влетит гигантский куб.
Built-in контроллеры не учитывают законы физики и не могут взаимодействовать с другими объектами. 
Rigidbody-контроллеры, и dynamic, и kinematic, могут влиять на динамические объекты. Dynamic-объекты подчиняются законам физики. Они могут двигать другие предметы, но это работает и в обратную сторону. Kinematic-объекты могут влиять на dynamic-объекты, но это не работает в обратную — на kinematic-объекты ничто не может повлиять. По умолчанию физические законы действуют только на dynamic-объекты. Это значит, что на них всегда влияет гравитация, а при движении есть инерция. Для остальных типов контроллеров эти условия не работают.
Built-in контроллеры позволяют персонажу подниматься по ступенькам или по наклонной поверхности. При этом он не будет съезжать вниз, если окажется на крутом склоне. У dynamic-объектов почти всё наоборот: они не умеют подниматься по ступенькам, но при этом съезжают на крутом склоне. Единственное, что их объединяет с предыдущим типом контроллера — они тоже могут подниматься по пологой поверхности.




19 Пользовательский интерфейс, принцип работы, основные используемые объекты.
Сначала обратимся к терминологии. Unity UI – это набор инструментов
пользовательского интерфейса (UI) для разработки пользовательского интерфейса для игр и приложений. Это система пользовательского интерфейса на основе игрового объекта, которая использует компоненты и представление игры для упорядочивания, позиционирования и стиля пользовательских интерфейсов.
Cцена, как частично упоминалось в первой главе, является ассетом, который
содержит игровые объекты. Сцена может иметь все игровые объекты или только
их часть, разделив на другие сцены.
        Для удобной настройки UI элементов можно перейти в режим 2D отображения, нажав на кнопку 2D на верхней панели окна сцены. При создании кнопки, также создается пару новых игровых объектов: Canvas (холст) и EventSystem.
Canvas – это игровой объект с компонентом Canvas, все элементы UI должны быть дочерними элементами данного игрового объекта. Canvas представляет из себя абстрактную область, внутри которой должны находиться и рендерится все элементы UI. Область Canvas отображается в виде прямоугольника на сцене, что позволяет настраивать UI элементы без необходимости постоянно видеть окно игры.
Второй игровой объект, EventSystem – нужен, чтобы обрабатывать ввод, Raycasting и отправку событий. Именно EventSystem отвечает за обработку событий на сцене Unity. На сцене должна быть только одна такая система. Как пример, сам Canvas использует игровой объект EventSystem, чтобы помочь системе обмена сообщениями.


20 Свойства и принципы работы с системой частиц.
Система частиц моделирует и визуализирует множество небольших изображений или сеток, называемых частицами, для создания визуального эффекта. Каждая частица в системе представляет собой отдельный графический элемент эффекта. Система имитирует каждую частицу вместе, чтобы создать впечатление полного эффекта.
Модуль Walking Particle
Здесь находятся основные параметры частиц. Разберем несколько, про остальные можно узнать методом «тыка» или же наводясь на название параметра:
− Duration – время выполнения системы частиц в секундах;
− Looping – повторное испускание частиц до остановки системы частиц.
Цикл перезапускается после достижения времени Duration;
− Prewarm – используется, только когда включен Looping. Система частиц
будет вести себя, как будто выполнила полный цикл при запуске;
− Start Delay – задержка в секундах перед тем, как система частиц начинает
испускать частицы;
− Start Lifetime – исходное время жизни частиц в секундах. После завершения времени частица уничтожается;
− Start Speed – исходная скорость частиц. Чем больше скорость частиц, тем
сильнее они будут распространяться;
− Play On Awake – если включена, система автоматически начнет генерировать частицы;
− Simulation Speed – определяет, анимируются ли частицы в локальном пространстве родительского объекта (таким образом, перемещаясь вместе с родительским объектом) в мировом пространстве, или же относительно пользовательского объекта (перемещаясь с пользовательским объектом по вашему выбору);
− Gravity Modifier – регулирует гравитацию частиц.
Модуль Render
Иногда может произойти такое, что частицы не отображаются, а если отображаются, то с непонятно розовым цветом. Чтобы это исправить, нужно перейти в модуль Renderer, отвечающий за то, как изображение частиц отображается, трансформируется, затеняется и перерисовывается другими частицами.
− Render Mode: как Unity создает визуализированное изображение из графического изображения (или сетки);
− Material: материал, который Unity использует для рендеринга частиц.
Модуль Emission
Он отвечает за за частоту и количество выпускаемых частиц.
− Rate Over Time – количество выпускаемых частиц в единицу времени;
− Rate Over Distance – количество выпускаемых частиц за единицу пройденного
расстояния;
− Burst – некоторое событие, позволяющее генерировать частицы с определенными условиями:
− Time – через какое время произойдет событие;
− Count – количество частиц, которые могут быть выпущены;
− Cycles – сколько раз произойдет событие;
− Interval – время между событиями;
− Probability – вероятность того, что каждое событие выпустит частицы
Модуль Shape
Он определяет объем или поверхность, с которой будут выпускаться частицы.
        Модуль Velocity over Lifetime
        Он позволяет контролировать скорость частиц в течение их «жизни» 
        Модуль Size over Lifetime
        Данный модуль позволяет изменять размер частиц со временем.
21 Что такое порядок выполнения функций? Как может использоваться?
        Если кратко - то вопрос ниже. Если более подробно, то вопрос № 50.
22 Какой класс считается основным для наследования в Unity?
MonoBehaviour – это базовый класс, от которого должны наследоваться все скрипты. Он необходим пользовательским скриптам, так как ни один компонент не может быть «прикреплён» к игровому объекту, если этот компонент не унаследован от базового класса MonoBehaviour. Данный класс содержит следующие основные методы:
− Awake – это метод, который вызывается единожды при “пробуждении” игрового объекта.
− OnEnable – метод, который вызывается при включении игрового объекта.
− Start – метод, который вызывается единожды перед вызовом метода Update.
− Update – это метод, который вызывается каждый кадр игры и нужен для
обновления состояния игры.
− FixedUpdate – главное его отличие от Update, что этот метод не зависит от
частоты кадров. Данный метод используется для просчёта физики.
− LateUpdate – это метод, который вызывается после метода обновления
игры (Update)
− OnDisable – метод, который вызывается, когда игровой объект отключается
− OnDestroy – метод, который вызывается при уничтожении объекта.
23 Можно ли создавать собственные функции в классе?
Ээээ, ну да - можно.
24 Какой метод вызывается при удалении класса (объекта)?
В контексте языка C# - это деструктор. Деструктор (destructor) – метод, автоматически вызываемый непосредственно перед удалением объекта (освобождением занимаемой им памяти). В классе может быть только один метод-деструктор, и он никогда не имеет параметров. Имя метода совпадает с именем класса, но перед ним ставится символ «тильда». 
Однако на деле при очистке сборщик мусора вызывает не деструктор, а метод Finalize. Все потому, что компилятор C# компилирует деструктор в конструкцию, которая эквивалентна следующей:
protected override void Finalize()
{
    try
    {
        // здесь идут инструкции деструктора
    }
    finally
    {
        base.Finalize();
    }
}
Метод Finalize уже определен в базовом для всех типов классе Object, однако данный метод нельзя так просто переопределить. И фактическая его реализация происходит через создание деструктора.
В контексте Unity:
− OnDisable – метод, который вызывается, когда игровой объект отключается, что это значит будет разобрано чуть дальше. 
− OnDestroy – метод, который вызывается при уничтожении объекта. Выше затрагивалась активность игрового объекта. У каждого объекта в инспекторе слева от имени поле с галочкой – она показывает, активен ли сейчас игровой объект. Верхняя панель инспектора Если убрать эту галочку, то в иерархии объектов данный объект будет помечен серым и будет вызван метод OnDisable
25 Какой класс отвечает за обработку нажатий?
В Unity класс Input отвечает за обработку ввода, включая нажатия клавиш и кнопок мыши.using UnityEngine;


void Update() {
   if (Input.GetKeyDown(KeyCode.Space)) {
       // Код
   }
   if (Input.GetMouseButtonDown(0)) {
       // Код ЛКМ
   }
}




26 Принципы работы с аудиофайлами и их проигрывание в Unity.
В Unity для работы с аудиофайлами используются компоненты AudioSource и AudioClip.




Пайплайн работы с аудио:
1. Импорт в ассеты проекта
2. Добавить аудио в объект 


public AudioClip audioClip;
private AudioSource audioSource;
void Start() {
   audioSource = gameObject.AddComponent<AudioSource>();
   audioSource.clip = audioClip;
}
ЛИБО через интерфейс


3. Проиграть

audioSource.Play();
//настройки
audioSource.volume = 0.5f;
audioSource.loop = true;


27 Свойства и принципы работы с анимацией и аниматором.


https://docs.unity3d.com/ScriptReference/Animator.html
https://www.youtube.com/watch?v=es3CtzMkrdQ


В Unity для управления анимацией используются компоненты Animator и Animation.
        Создается анимационный контроллер, который управляет анимационными состояниями и переходами между ними.
        В Animator Controller создаются состояния (States), каждая из которых представляет отдельную анимацию.
        Переходы (Transitions) задаются между состояниями, чтобы определять, как и когда анимации будут сменять друг друга.
        Параметры используются для контроля переходов. Они могут быть типа float, int, bool или trigger.
animator.SetBool("isRunning", true);
Компонент Animator:
Применяется к GameObject и связывается с Animator 
Controller.
public Animator animator;


void Start() {
   animator = GetComponent<Animator>();
}




28 Анимация по ключевым точкам в Unity.


https://learn.unity.com/tutorial/creating-keyframed-animation-in-timeline#5ce5c55cedbc2a1ab237d0fa
https://www.youtube.com/watch?v=uhU9vuLTfzU
Анимация по ключевым точкам (keyframe animation) в Unity осуществляется через компонент Animation и создание анимационных клипов в Animation Window.


        В Animation Window создаются ключевые кадры (keyframes) для различных параметров (позиция, вращение, масштаб и т.д.).


        Ключевые кадры редактируются для создания плавных переходов между состояниями объекта.




29 Придание движение объектам, различные способы реализации.
transform
using UnityEngine;


public class MoveObject : MonoBehaviour
{
   public float speed = 5f;




   void Update()
   {
       transform.Translate(Vector3.forward * speed * Time.deltaTime);
   }
}


Физическое движение
public class MoveObjectWithPhysics : MonoBehaviour
{
   public float speed = 5f;
   private Rigidbody rb;




   void Start()
   {
       rb = GetComponent<Rigidbody>();
   }




   void FixedUpdate()
   {
       rb.MovePosition(transform.position + transform.forward * speed * Time.deltaTime);
   }
}






Анимации
public class MoveWithAnimation : MonoBehaviour
{
   private Animator animator;




   void Start()
   {
       animator = GetComponent<Animator>();
       animator.Play("MoveAnimation");
   }
}




Для сложных перемещений, таких как перемещение по заданному маршруту, можно использовать систему навигации (NavMesh).
using UnityEngine;
using UnityEngine.AI;


public class MoveWithNavMesh : MonoBehaviour
{
   public Transform target;
   private NavMeshAgent agent;


   void Start()
   {
       agent = GetComponent<NavMeshAgent>();
       agent.SetDestination(target.position);
   }
}


Для понимания: сложное скрипт движение
public class CustomMovement : MonoBehaviour
{
   public float amplitude = 5f;
   public float frequency = 1f;




   void Update()
   {
       float x = Mathf.Sin(Time.time * frequency) * amplitude;
       transform.position = new Vector3(x, transform.position.y, transform.position.z);
   }
}




30 Задание цвета объекту с помощью скриптинга.
Компонент renderer


public class ChangeColor : MonoBehaviour
{
   public Color newColor = Color.red;




   void Start()
   {
       // Получаем компонент Renderer объекта
       Renderer renderer = GetComponent<Renderer>();




       // Устанавливаем новый цвет для материала
       renderer.material.color = newColor;
   }
}




using UnityEngine;


public class ChangeSpecificMaterialColor : MonoBehaviour
{
   public Color newColor = Color.blue;
   public int materialIndex = 1;


   void Start()
   {
       Renderer renderer = GetComponent<Renderer>();


       // Проверка, что индекс материала находится в допустимых пределах
       if (materialIndex >= 0 && materialIndex < renderer.materials.Length)
       {
           renderer.materials[materialIndex].color = newColor;
       }
       else
       {
           Debug.LogWarning("Material index out of range");
       }
   }
}
	31 Создание материала объекта в Unity.


https://docs.unity3d.com/ru/2019.4/Manual/Materials.html


Используйте пункт главного меню Assets->Create->Material или контекстное меню окна Project (Project View) для создания нового материала. После создания, вы можете применить его к объекту и настроить все его свойства в инспекторе (Inspector). Для применения материала к объекту, просто перетащите его из окна Project (Project View) на любой объект в сцене (Scene) или иерархии сцены (Hierarchy).


  

Установка свойств материала
Вы можете выбрать какой именно шейдер будет использоваться в конкретном материале. Для этого просто раскройте выпадающее меню Shader в инспекторе и выберите подходящий вам шейдер. Выбранный вами шейдер будет задавать доступные для изменения свойства. Свойствами могут выглядеть как цвета, слайдеры, текстуры, числа или векторы. Если вы применили материал к активному объекту в сцене, вы увидите, как в реальном времени будут применяться изменяемые вами свойства.
Существует два способа присваивания текстуры (Texture) свойству.
1. С помощью перетаскивания текстуры из окна Project на квадратную область свойства Texture
2. С помощью нажатия кнопки Select и выбора текстуры из появившегося выпадающего списка
using UnityEngine;


public class ApplyMultipleMaterials : MonoBehaviour
{
   public Texture texture1;
   public Texture texture2;


   void Start()
   {
       // Создание двух новых материалов
       Material material1 = new Material(Shader.Find("Standard"));
       Material material2 = new Material(Shader.Find("Standard"));


       // Задание текстур для новых материалов
       material1.mainTexture = texture1;
       material2.mainTexture = texture2;


       // Применение материалов к объекту
       Renderer renderer = GetComponent<Renderer>();
       renderer.materials = new Material[] { material1, material2 };
   }
}
	





32 Что такое шейдеры материала?
(в доке плохо описано, гпт)
Шейдеры материала в Unity — это небольшие программы, написанные на языке ShaderLab или HLSL (High-Level Shading Language), которые определяют, как поверхность объекта отображается в игре. Они определяют, как свет взаимодействует с поверхностью объекта, какие текстуры используются, и какие визуальные эффекты применяются.
Основные компоненты шейдера материала
1. Vertex Shader (Вершинный шейдер): Обрабатывает каждый вершину модели, выполняя такие операции, как трансформация координат из пространства модели в пространство экрана, вычисление нормалей и текстурных координат.
2. Fragment Shader (Фрагментный шейдер, или пиксельный шейдер): Обрабатывает каждый фрагмент (пиксель) поверхности объекта, определяя его окончательный цвет. Это может включать в себя расчеты освещения, текстурирование, и другие эффекты.
3. Surface Shader (Поверхностный шейдер): Высокоуровневый шейдер, который упрощает написание сложных материалов. Он автоматически генерирует вершины и фрагменты шейдеров, используя более простой синтаксис.
Основные свойства материала
Материалы в Unity объединяют шейдеры и текстуры для задания визуального вида объектов. Основные свойства материала включают:
* Альбедо: Основной цвет материала, на который может накладываться текстура.
* Металличность (Metallic): Определяет, насколько материал ведет себя как металл.
* Гладкость (Smoothness): Определяет, насколько гладким или шероховатым выглядит материал.
* Нормали (Normal map): Специальная текстура, используемая для добавления деталей на поверхности без изменения геометрии.
* Высотная карта (Height map): Используется для параллакс-маппинга и других техник, добавляющих объем поверхности.
* Эмиссия (Emission): Цвет и интенсивность света, который материал может излучать сам по себе.
Примеры использования шейдеров
1. Ламбертовский шейдер: Простое освещение, учитывающее только диффузное освещение.
2. Фонговский шейдер: Учитывает диффузное и зеркальное освещение, создавая более реалистичный вид.
3. PBR (Physically Based Rendering): Современные шейдеры, которые используют физически корректные модели освещения для создания реалистичных материалов.
33 Объект Terrain, методы реализации, особенности.


Кратко:очень сложный билдер 3д объекта с оптимизациями


Редактор Unity включает в себя встроенный набор элементов ландшафта, который позволяет добавлять ландшафты в вашу игру. В редакторе вы можете создавать несколько фрагментов ландшафта, изменять высоту или внешний вид вашего ландшафта, а также добавлять к нему деревья или траву. Во время выполнения Unity оптимизирует встроенный рендеринг Terrain для повышения эффективности. 


Основные компоненты и инструменты объекта Terrain
1. Terrain Component (Компонент Terrain): Это основной компонент, который добавляется к игровому объекту для создания и управления ландшафтом. В инспекторе отображаются все настройки и инструменты для редактирования террейна.
2. Terrain Data (Данные террейна): Хранит информацию о высотах, текстурах, растительности и других деталях ландшафта. Этот объект используется для совместного использования данных между разными террейнами.
3. Heightmap (Карта высот): 2D изображение, где значения пикселей представляют высоту на террейне. Может быть импортировано из внешнего файла для создания детализированного ландшафта.
Методы создания и редактирования террейна
1. Создание террейна:
   * В меню Unity выберите GameObject -> 3D Object -> Terrain.
   * Новый объект террейна появится в сцене с компонентом Terrain.
2. Редактирование высоты:
   * В инспекторе выберите вкладку Paint Terrain.
   * Используйте инструменты Raise/Lower Terrain, Paint Height, Smooth Height для изменения высоты террейна.
3. Текстурирование террейна:
   * В той же вкладке Paint Terrain выберите Paint Texture.
   * Добавьте слои текстур, используя кнопку Edit Terrain Layers -> Create Layer.
   * Выберите текстуру и рисуйте ею по террейну, создавая разнообразные участки земли (трава, песок, камни и т.д.).
4. Добавление растительности:
   * В инспекторе выберите вкладку Paint Details.
   * Добавьте траву или детализированные объекты (камни, кусты) через Edit Details.
   * Разместите растительность на террейне, рисуя или используя инструменты для массового размещения.




34 Чем объект Terrain отличается от обычного трехмерного объекта.


Высокая детализация на больших территориях:
* Уровни детализации (LOD): Terrain часто использует различные уровни детализации для отображения близких и дальних объектов. Это позволяет сохранять высокую производительность, так как детали отображаются только на близких расстояниях.
* Теселляция: Для повышения детализации поверхности terrain может использоваться теселляция, которая позволяет динамически изменять геометрию поверхности в зависимости от расстояния до камеры.
Процедурное создание и модификация:
* Высотные карты: Terrain часто генерируется на основе высотных карт (height maps), где значения яркости пикселей карты определяют высоту поверхности в данной точке.
* Инструменты редактирования: Многие игровые движки предлагают инструменты для интерактивного создания и модификации terrain, включая рисование высот, текстурирование, добавление растительности и других объектов.
Оптимизация производительности:
* Разбиение на чанки: Terrain обычно делится на маленькие чанки (chunks), которые могут подгружаться и выгружаться по мере необходимости, что позволяет оптимизировать использование памяти и производительности.
* Окклюзия и отбраковка (culling): Используются техники окклюзии и отбраковки, чтобы не рендерить части terrain, которые не видны игроку.
Особенности текстурирования:
* Смешивание текстур: Terrain часто использует смешивание нескольких текстур для создания реалистичной поверхности. Например, разные текстуры могут применяться в зависимости от высоты, уклона и других параметров поверхности.
* Сложные шейдеры: Для terrain могут использоваться сложные шейдеры, которые имитируют эффекты окружающей среды, такие как снежные шапки, песчаные дюны и т.д.
Интеграция с физикой и игровыми механиками:
* Навигация и коллизии: Terrain интегрируется с системами навигации и коллизии, чтобы персонажи и объекты могли корректно взаимодействовать с поверхностью.
* Интерактивные элементы: На terrain могут быть размещены интерактивные элементы, такие как деревья, кусты, камни и другие объекты, которые влияют на геймплей.
35 Каковы основные характеристики Unity3D?
Сайт по гемдеву: 
Характеристики Unity
* Это мультиплатформенный игровой движок с такими функциями, как (3D-объекты, физика, анимация, сценарии, освещение и т. Д.)

* Сопровождающий редактор сценариев

* MonoDevelop (Win / Mac)

* Он также может использовать Visual Studio (Windows)

* Редактор 3D ландшафта

* Менеджер анимации 3D-объектов

* Система графического интерфейса пользователя

* Экспортер исполняемых файлов для многих платформ Веб-плеер / Android / Собственное приложение / Wii

* В Unity 3D вы можете собирать искусство и ресурсы в сцены и среды, например добавлять специальные эффекты, физику и анимацию, освещение и т. Д.


Гпт: 
Кроссплатформенность:
   * Поддержка множества платформ, включая Windows, macOS, Linux, iOS, Android, WebGL, PlayStation, Xbox, Nintendo Switch и другие.
   * Возможность разрабатывать игру один раз и экспортировать её на разные платформы с минимальными изменениями.
Графические возможности:
   * Поддержка высококачественной 2D и 3D графики.
   * Встроенные инструменты для работы с освещением, тенями, шейдерами и визуальными эффектами.
   * Поддержка физически корректного рендеринга (PBR).
Физика и анимация:
   * Встроенные физические движки (например, Nvidia PhysX) для симуляции реальных физических взаимодействий.
   * Мощные инструменты для создания и управления анимациями, включая механизмы инверсной кинематики.
Редактор сцен:
   * Интуитивно понятный интерфейс для создания и редактирования сцен.
   * Поддержка drag-and-drop для размещения объектов в сцене.
Скриптинг:
   * Скриптовый язык C# для написания логики игры.
   * Интеграция с Visual Studio для удобного редактирования кода и отладки.
Ассеты и расширения:
   * Большой ассортимент ассетов в Unity Asset Store, включая модели, звуки, текстуры и скрипты.
   * Возможность создания собственных ассетов и расширений.






36 Игровой движок. Что собой представляет и какие проблемы решает?


Игрово́й движо́к (англ. game engine) — базовое программное обеспечение компьютерной игры[1]. Разделение игры и игрового движка часто расплывчато, и не всегда студии проводят чёткую границу между ними. Но в общем случае термин «игровой движок» применяется для того программного обеспечения, которое пригодно для повторного использования и расширения, и тем самым может быть рассмотрено как основание для разработки множества различных игр без существенных изменений[2]. 




37 Что такое Game Object? Что такое сцена?
GameObjects — это основные объекты Unity, представляющие персонажей, реквизит и декорации. Сами по себе они мало что делают, но действуют как контейнеры для компонентов , которые реализуют реальную функциональность.
Например, объект Light создается путем присоединения компонента Light к GameObject.
К GameObject всегда прикреплен компонент Transform (для представления положения и ориентации), и удалить его невозможно. Другие компоненты, придающие объекту функциональность, можно добавить из меню «Компонент » редактора или из сценария. 
Сцены содержат объекты вашей игры. Они могут использоваться для создания главного меню, отдельных уровней и для других целей. Можно считать каждый файл сцены отдельным игровым уровнем. В каждой сцене можно разместить объекты окружения, заграждения, декорации, по кусочкам создавая дизайн и саму игру.
380? Из чего состоит 3д модель?
Меш (Mesh): содержит все вершины, рёбра, треугольники, нормали и UV-данные модели. Meshes составляют большую часть создаваемых вами трёхмерных миров. 
Трехмерная модель состоит из множества точек, которые соединяются между собой гранями и образуют полигоны.
39 За что отвечает вкладка Lighting?


Источники света являются фундаментальной частью графического рендеринга, поскольку они определяют затенение объекта и тени, которые он отбрасывает. Дополнительные сведения о концепциях освещения в Unity.
Окно настроек освещения сцены вызывается через Window — Lighting, и состоит из трёх вкладок: Object, Scene, Lightmaps. Для запуска рендера освещения используется кнопка Build в самом низу окна.


40 Какие объекты добавляются по умолчанию?


По умолчанию на сцене создается главная камера, без которой мы бы не увидели в игре вообще ничего. Кликом по камере в панели иерархии открывается панель Инспектора игрового объекта, в которой отображаются свойства выбранного объекта.


41 Какой компонент есть у каждого объекта?


По умолчанию у всех игровых объектов есть компонент Transform. Потому что Transform диктует, где расположен игровой объект, и как он поворачивается и масштабируется. Без компонента Transform, игровой объект не будет иметь место в мире.




42 Различия между Blueprint скриптингом и кодингом.


Blueprint скриптинг и кодинг - это два различных метода программирования в игровой индустрии, которые используются для создания игровой логики и взаимодействия в игровых проектах. Вот некоторые основные различия между ними:


Язык программирования: Blueprint скриптинг использует графический интерфейс, позволяющий создавать логику с использованием блоков, связанных линиями, что делает его доступным для дизайнеров и художников без глубоких знаний программирования. В то время как кодинг включает в себя написание программного кода на языках программирования.
Скорость разработки: благодаря графическому подходу и интуитивному интерфейсу, Blueprint скриптинг может позволить быстрее прототипировать и создавать простые взаимодействия и системы в игре. Кодинг может быть более времязатратным из-за необходимости написания и отладки кода.
Производительность: кодинг обычно обеспечивает более высокую производительность и оптимизацию, так как разработчику легче контролировать ресурсы и процессы игры при написании кода напрямую. Однако Blueprint скриптинг в Unreal Engine 4 хорошо оптимизирован и в большинстве случаев обеспечивает приемлемую производительность.


43 Что такое Blueprint скриптинг?


Blueprints — это система визуального скриптинга Unreal Engine 4. Она является быстрым способом создания прототипов игр. Вместо построчного написания кода всё можно делать визуально: перетаскивать ноды (узлы), задавать их свойства в интерфейсе и соединять их «провода».


Кроме быстрого прототипирования, Blueprints также упрощают создание скриптов для непрограммистов.


44 Что такое Prefabs в Unity 3D?


Префабы - это набор заранее установленных игровых объектов GameObjects и компонентов Components, которые используются более одного раза за всю игру.
Вы можете создать префаб, выбрав Asset > Create Prefab и перетащив объект со сцены в “пустой” префаб, появившийся в проекте. После чего можно создавать экземпляры префаба просто перетаскивая его из окна Project на сцену. Имена объектов-экземпляров префабы, будут подсвечиваться синим в окне Hierarchy (имена обычных объектов имеют чёрный цвет).
Как уже упоминалось выше, изменения в префабе автоматически применятся ко всем её экземплярам, однако вы можете изменять и отдельные экземпляры. Это полезно например в случае, когда вы желаете создать несколько похожих NPC, но с внешними различиями, чтобы добавить реалистичности. Чтобы было чётко видно, что свойство в экземпляре префаба изменено, оно показывается в инспекторе жирным шрифтом (если к экземпляру префаба добавлен совершенно новый компонент, то все его свойства будут написаны жирным шрифтом).


45 Как происходит обращение к компонентам?


Наиболее простым и распространенным является случай, когда скрипту необходимо обратиться к другим компонентам, присоединенных к тому же GameObject. Как упоминалось во разделе Введение, компонент на самом деле является экземпляром класса, так что первым шагом будет получение ссылки на экземпляр компонента, с которым вы хотите работать. Это делается с помощью функции GetComponent. Типично, объект компонента сохраняют в переменную, это делается в C# посредством следующего синтаксиса:
void Start () {
    Rigidbody rb = GetComponent<Rigidbody>();
}
Как только у вас есть ссылка на экземпляр компонента, вы можете устанавливать значения его свойств, тех же, которые вы можете изменить в окне Inspector:
void Start () {
    Rigidbody rb = GetComponent<Rigidbody>();
    
    // Change the mass of the object's Rigidbody.
    rb.mass = 10f;
}


46 Как происходит обращение к другим объектам?
   1. Связывание объектов через переменные
Самый простой способ найти нужный игровой объект - добавить в скрипт переменную типа GameObject с уровнем доступа public:
public class Enemy : MonoBehaviour {
    public GameObject player;
  }
   2. Нахождение дочерних объектов
Иногда игровая сцена может использовать несколько объектов одного типа, таких как враги, путевые точки и препятствия. Может возникнуть необходимость отслеживания их в определенном скрипте, который управляет или реагирует на них (например, все путевые точки могут потребоваться для скрипта поиска пути). Можно использовать переменные для связывания этих объектов, но это сделает процесс проектирования утомительным, если каждую новую путевую точку нужно будет перетащить в переменную в скрипте. Аналогично, при удалении путевой точки придется удалять ссылку на отсутствующий объект. В случаях, наподобие этого, чаще всего удобно управлять набором объектов, сделав их дочерними одного родительского объекта. Дочерние объекты могут быть получены, используя компонент Transform родителя (так как все игровые объекты неявно содержат Transform):
using UnityEngine;


public class WaypointManager : MonoBehaviour {
    public Transform[] waypoints;
    
    void Start() {
        waypoints = new Transform[transform.childCount];
        int i = 0;
        
        foreach (Transform t in transform) {
            waypoints[i++] = t;
        }
    }
}
   3. Нахождение объектов по имени или тегу
Нахождение игровых объектов в любом месте иерархии доступно всегда, когда у вас есть некоторая информация, по которой их можно идентифицировать. Отдельные объекты могут быть получены по имени, используя функцию GameObject.Find:
GameObject player;


void Start() {
    player = GameObject.Find("MainHeroCharacter");
}


47 Функции событий, какие бывают? Зачем используются?
Скрипт в Unity не похож на традиционную идею программы, где код работает постоянно в цикле, пока не завершит свою задачу. Вместо этого, Unity периодически передаёт управление скрипту при вызове определённых объявленных в нём функций. Как только функция завершает исполнение, управление возвращается обратно к Unity. Эти функции известны как функции событий, т.к. их активирует Unity в ответ на события, которые происходят в процессе игры. Unity использует схему именования, чтобы определить, какую функцию вызвать для определённого события. Например, вы уже видели функцию Update (вызывается перед сменой кадра) и функцию Start (вызывается прямо перед первым кадром объекта). 
   * Update-события (Update вызывается перед отрисовкой кадра и перед расчётом анимаций)
   * События физики (Физический движок сообщит о столкновениях с объектом с помощью вызова функций событий в скрипте этого объекта. Функции OnCollisionEnter, OnCollisionStay и OnCollisionExit будут вызваны по началу, продолжению и завершению контакта. Соответствующие функции OnTriggerEnter, OnTriggerStay и OnTriggerExit будут вызваны когда коллайдер объекта настроен как Trigger (т.е. этот коллайдер просто определяет, что его что-то пересекает и не реагирует физически). )
   * События инициализации (Зачастую полезно иметь возможность вызвать код инициализации перед любыми обновлениями, происходящими во время игры. Функция Start вызывается до обновления первого кадра или физики объекта. Функция Awake вызывается для каждого объекта в сцене в момент загрузки сцены. )
   * События GUI(В Unity есть система для отрисовки элементов управления GUI поверх всего происходящего в сцене и реагирования на клики по этим элементам. Этот код обрабатывается несколько иначе, нежели обычное обновление кадра, так что он должен быть помещён в функцию OnGUI, которая будет периодически вызываться.)
48 Как происходит компиляция скриптов?


Есть следующие фазы компиляции:-
Фаза 1: Выполняются скрипты из папок с именами Standard Assets, Pro Standard Assets и Plugins.
Фаза 2: Выполняются Сценарии редактора в папках с именем Editor, которые находятся в любом месте внутри папок верхнего уровня с именами Standard Assets, Pro Standard Assets и Plugins.
Фаза 3: Все прочие скрипты, не находящиеся в папке Editor.
Фаза 4: Все оставшиеся скрипты (т.е. находящиеся в папке Editor).
Дополнительно, любой скрипт, находящийся в папке WebPlayerTemplates, в самом верху папки Assets, вообще не будет скомпилирован. Это поведение немного отличается для вложенных папок с другими именами (например, Scripts/Editor работает как папка для скриптов редактора и Scripts/WebPlayerTemplates не помешает компиляции).


49 Что такое Атрибуты? Как используются в скриптинге?
Атрибуты (Attributes) это маркеры, которые могут быть помещены перед классом, свойствами или функциями в скрипте, чтобы указать особое поведение. Например атрибут HideInInspector может быть добавлен перед объявлением свойства для предотвращения отображения этого свойства в инспекторе, даже если оно публичное. В JavaScript имя атрибута начинается со знака “@”, а в C# и Boo, он помещается между квадратными скобками:
  

Дальше GPT, но вроде все адекватно 
Примеры использования атрибутов в Unity
        1.        Системные атрибуты:
        •        [SerializeField]: позволяет сериализовать приватное поле и сделать его видимым в инспекторе Unity.
        •        [Range(min, max)]: ограничивает значение числового поля определённым диапазоном и добавляет слайдер в инспекторе Unity.
        •        [Header("Header Name")]: добавляет заголовок перед полем в инспекторе Unity.
        2.        Пользовательские атрибуты:
        •        Пользователь может создавать собственные атрибуты, наследуя их от System.Attribute и применяя к нужным элементам кода.


  

  

Использование атрибутов в скриптинге Unity
        1.        Управление отображением в инспекторе:
Атрибуты позволяют разработчикам контролировать, как поля и свойства будут отображаться в редакторе Unity, улучшая пользовательский интерфейс и удобство настройки.
        2.        Валидация данных и ограничение значений:
Атрибуты, такие как [Range], помогают ограничивать значения, что предотвращает ошибки и упрощает работу с объектами.
        3.        Создание пользовательских инспекторов:
Можно создавать свои инспекторы, расширяя функциональность редактора Unity. Это может включать сложные настройки для компонентов, используя кастомные атрибуты и редакторы.
50 Как работает порядок выполнения функций событий?
В скриптинге Unity есть некоторое количество функций события, которые исполняются в заранее заданном порядке по мере исполнения скрипта. Этот порядок исполнения описан ниже:
Редактор
   * Reset: Reset (сброс) вызывается для инициализации свойств скрипта, когда он только присоединяется к объекту и тогда, когда используется команда Reset.
Первая загрузка сцены
Эти функции вызываются при запуске сцены (один раз для каждого объекта на сцене).
   * Awake: Эта функция всегда вызывается до любых функций Start и также после того, как префаб был вызван в сцену (если GameObject неактивен на момент старта, Awake не будет вызван, пока GameObject не будет активирован, или функция в каком-нибудь прикреплённом скрипте не вызовет Awake).
   *    * OnEnable: (вызывается только если объект активен): Эта функция вызывается сразу после включения объекта. Это происходит при создании образца MonoBehaviour, например, при загрузке уровня или был вызван GameObject с компонентом скрипта.
   *    * OnLevelWasLoaded: This function is executed to inform the game that a new level has been loaded.
Учтите, что для объектов, добавленных в сцену сразу, функции Awake и OnEnable для всех скриптов будут вызваны до вызова Start, Update и т.д. Естественно, для объектов вызванных во время игрового процесса такого не будет. 
Перед первым обновлением кадра
   * Start: Функция Start вызывается до обновления первого кадра(first frame) только если скрипт включен.
Для объектов добавленных на сцену, функция Start будет вызываться во всех скриптах до функции Update. Естественно, это не может быть обеспечено при создании объекта непосредственно во время игры.
Между кадрами
   * OnApplicationPause: Эта функция вызывается в конце кадра, во время во время которого вызывается пауза, что эффективно между обычными обновлениями кадров. Один дополнительный кадр будет выдан после вызова OnApplicationPause, чтобы позволить игре отобразить графику, которая указывает на состояние паузы.
Порядок обновления
Когда вы отслеживаете игровую логику и взаимодействия, анимации, позиции камеры и т.д. есть несколько разных событий, которые вы можете использовать. По общему шаблону, большая часть задач выполняется внутри функции Update, но есть также ещё другие функции, которые вы можете использовать.
   * FixedUpdate: Зачастую случается, что FixedUpdate вызывается чаще чем Update. FU может быть вызван несколько раз за кадр, если FPS низок и функция может быть и вовсе не вызвана между кадрами, если FPS высок. Все физические вычисления и обновления происходят сразу после FixedUpdate. При применении расчётов передвижения внутри FixedUpdate, вам не нужно умножать ваши значения на Time.deltaTime. Потому что FixedUpdate вызывается в соответствии с надёжным таймером, независящим от частоты кадров. 
   *    * Update: Update вызывается раз за кадр. Это главная функция для обновлений кадров.
   *    * LateUpdate: LateUpdate вызывается раз в кадр, после завершения Update. Любые вычисления произведённые в Update будут уже выполнены на момент начала LateUpdate. Часто LateUpdate используют для преследующей камеры от третьего лица. Если вы перемещаете и поворачиваете персонажа в Update, вы можете выполнить все вычисления перемещения и вращения камеры в LateUpdate. Это обеспечит то, что персонаж будет двигаться до того, как камера отследит его позицию. 
Рендеринг
   * OnPreCull: Вызывается до того, как камера отсечёт сцену. Отсечение определяет, какие объекты будут видны в камере. OnPreCull вызывается прямо перед тем, как начинается отсечение.
   *    * OnBecameVisible/OnBecameInvisible: Вызывается тогда, когда объект становится видимым/невидимым любой камере.
   *    * OnWillRenderObject: Вызывается один раз для каждой камеры, если объект в поле зрения.
   *    * OnPreRender: Вызывается перед тем, как камера начнёт рендерить сцену.
   *    * OnRenderObject: Вызывается, после того, как все обычные рендеры сцены завершатся. Вы можете использовать класс GL или Graphics.DrawMeshNow, чтобы рисовать пользовательскую геометрию в данной точке.
   *    * OnPostRender: Вызывается после того, как камера завершит рендер сцены.
   *    * OnRenderImage(только в Pro версии): Вызывается после завершения рендера сцены, для возможности пост-обработки изображения экрана.
   *    * OnGUI: Вызывается несколько раз за кадр и отвечает за элементы интерфейса (GUI). Сначала обрабатываются события макета и раскраски, после чего идут события клавиатуры/мышки для каждого события.
   *    * OnDrawGizmos Используется для отрисовки гизмо в окне Scene View в целях визуализации.
Сопрограммы
Нормальные обновления сопрограмм запускаются после завершения из функции Update. Сопрограмма это функция, которая приостанавливает своё исполнение (yield), пока данные YieldInstruction не завершатся. Разные способы использования сопрограмм:
   * yield Сопрограмма продолжит выполнение, после того, как все Update функции были вызваны в следующем кадре.
   *    * yield WaitForSeconds Продолжает выполнение после заданной временной задержки, и после все Update функций, вызванных в итоговом кадре.
   *    * yield WaitForFixedUpdate Продолжает выполнение после того, как все функции FixedUpdate были вызваны во всех скриптах
   *    * yield WWW продолжает выполнение после завершения WWW-загрузки.
   *    * yield StartCoroutine сцепляет сопрограмму, и будет ждать, пока не завершится сопрограмма MyFunc.
Когда объект разрушается
   * OnDestroy: Эта функция вызывается после всех обновлений кадра в последнем кадре объекта, пока он ещё существует (объект может быть уничтожен при помощи Object.Destroy или при закрытии сцены).
При выходе
Эти функции вызываются во всех активных объектах в вашей сцене:
   * OnApplicationQuit: Эта функция вызывается для всех игровых объектов перед тем, как приложение закрывается. В редакторе вызывается тогда, когда игрок останавливает игровой режим. В веб-плеере вызывается по закрытия веб окна.
   *    * OnDisable: Эта функция вызывается, когда объект отключается или становится неактивным.
   *   

51 С какими форматами аудио работает Unity?
Ответ убил:
          
52 Что такое Canvas в Unity?
Canvas (полотно) – это область, внутри которой находятся все элементы UI (пользовательского интерфейса). Полотно – это игровой объект (Game Object), с добавленным к нему компонентом Canvas. Все элементы UI должны быть дочерними этому Canvas. 
Когда вы создаете новый элемент UI, такой как изображение (Image), используя меню GameObject > UI > Image, вместе с ним автоматически создается и Canvas, если до этого на сцене его еще не было. Элемент UI создается дочерним этому Canvas. 
Область Canvas отображается в виде прямоугольника в окне Scene View. Это облегчает процесс расположения элементов UI без необходимости видеть игровое окно (Game View).
Canvas использует объект EventSystem для помощи системе обмена сообщениями.


53 Чем отличается пространство экрана камеры от пространства игрового мира?
В режиме Screen Space, холст отображается как если бы он был нарисован на плоском объекте, на некотором расстоянии заданной камеры. Экранный размер интерфейса не меняется с расстоянием, т.к. он всегда масштабируется чтобы в точности заполнять пирамиду видимости камеры (camera frustum). Если размер или разрешение экрана, или пирамида видимости, изменяются – интерфейс автоматически перемасштабируется, чтобы помещаться. Любые 3д объекты сцены, расположенные ближе к камере, чем плоскость интерфейса, будут отрисованы “над” интерфейсов, в то время как остальные объекты, находящиеся за плоскостью, будут загорожены.






World Space рисует интерфейс, как если бы он был плоским объектом сцены. В отличие от режима Screen Space - Camera, плоскость не обязана быть перпендикулярной направлению камеры, и может быть ориентирована как угодно. Размер холста может быть установлен через его Rect Transform, но его экранный размер будет зависеть от угла зрения и расстояния от камеры. Другие объекты сцены могут проходить сзади, сквозь, или спереди холста.
54 Что такое переменная?
Переменные — это контейнеры, используемые для хранения данных и управления ими в проектах Unity. У них есть имя и определенный тип данных. Другими словами, переменные похожи на помеченные коробки, в которых хранится информация.
55 Типы источников света. Освещение объектов с использованием шейдеров.
В Unity доступно 5 типов источников света:
      * Directional Light. Самый простой, имитирует солнечный свет. Представляет из себя бесконечное множество параллельных друг другу лучей.
      * Point Light. Точечный источник света, то есть лучи расходятся во все стороны из одной точки. Хорошим примером такого источника света будет обычная лампочка.
      * Area Light. Источник света, имеющий площадь. Представьте себе прямоугольную панель, из которой исходит свет, это и будет area light. Такие источники света чаще всего используются в офисах, торговых центрах и других нежилых помещениях, где надо освещать большие пространства.
      * Ambient Light. Заполняющий свет, не имеющий источника. Примеры использования: осветить слишком тёмные тени; добавить атмосферности подземелью, заполнив его едва заметным светом биолюминисцентных растений.
      * Light Probes. Особый источник света, влияющий исключительно на динамические объекты. Технически это не источник света, но для простоты назовём его так.


В Unity освещение объектов с использованием шейдеров является ключевым аспектом создания реалистичной графики. Шейдеры — это программы, которые работают на графическом процессоре (GPU) и определяют, как должны выглядеть объекты. Они могут быть использованы для создания различных эффектов, включая освещение.
Основные типы шейдеров
        1.        Vertex Shader (Вершинный шейдер): Обрабатывает вершины полигона. Вершинный шейдер может изменять позицию, цвет и другие свойства вершин.
        2.        Fragment Shader (Фрагментный шейдер): Обрабатывает каждый фрагмент (пиксель) полигона, определяя его цвет и другие свойства.


  

  

  

  

  

  

  

  

вот ссылка на источник на всякий случай тык


56 Карта нормалей. Альбедо, Цвет и Прозрачность.
GPT больше всех выдал что-то похожее на правду
Карта нормалей (Normal Map)
Карта нормалей (Normal Map) используется для имитации мелких деталей на поверхности объекта, создавая иллюзию сложной геометрии без увеличения количества полигонов. Она хранит информацию о направлении нормалей для каждой точки поверхности, что позволяет свету реагировать на поверхность так, как будто она имеет более детализированную геометрию.
  

Альбедо (Albedo)
Альбедо (Albedo) — это базовый цвет объекта, который не учитывает эффекты освещения, такие как тени или отражения. Карта альбедо хранит информацию о цвете каждого пикселя поверхности.
  



Цвет (Color)
Цвет в контексте шейдеров может быть свойством, которое задается непосредственно в редакторе или через код. Он может быть использован для умножения на текстуру, чтобы изменить её оттенок или интенсивность.
  

Прозрачность (Transparency)
Прозрачность может быть реализована различными способами, включая использование альфа-канала текстуры или отдельной карты прозрачности.
  



57 Настройка тени. Направленные светлые тени.
В Unity Pro все источники света могут опционально порождать тени. Это достигается выбором одной из опций Hard Shadows или Soft Shadows свойства Shadow Type для каждого источника света.
на этом инфа из доки Unity закончилась, так что вот GPT (вроде, тоже адекватно)
В Unity, чтобы создать направленные светлые тени, нужно настроить источник света (Light) и использовать тени с мягкими краями (Soft Shadows). Вот пошаговая инструкция для настройки таких теней:
1. Настройка источника света
        1.        Создайте или выберите Directional Light:
        •        В меню Unity выберите GameObject > Light > Directional Light.
        •        Если источник света уже существует, выберите его в Hierarchy.
        2.        Настройка теней:
        •        В инспекторе (Inspector) у выбранного источника света установите следующие параметры:
        •        Type: Directional.
        •        Shadow Type: Soft Shadows. Это создаст мягкие тени.
        •        Shadow Strength: Установите значение по вкусу (например, 0.8 для менее интенсивных теней).
        •        Shadow Resolution: Установите в зависимости от требований вашего проекта (Medium, High, или Very High).
        •        Shadow Distance: Установите максимальное расстояние, на котором будут видны тени.
        •        Bias и Normal Bias: Подберите значения, чтобы уменьшить артефакты теней.
2. Настройка теней на объектах
        1.        Убедитесь, что объекты отбрасывают тени:
        •        Выберите объект в Hierarchy.
        •        В инспекторе, в компоненте Mesh Renderer или соответствующем компоненте, установите:
        •        Cast Shadows: On.
        •        Receive Shadows: On, если объект должен получать тени от других объектов.
3. Настройка глобального освещения и теней
        1.        Настройка параметров качества теней:
        •        В меню Unity выберите Edit > Project Settings > Quality.
        •        Выберите уровень качества, который будет использоваться (например, High).
        •        В разделе Shadows установите:
        •        Shadow Resolution: Какое разрешение будет у теней (Low, Medium, High, или Very High).
        •        Shadow Projection: Stable Fit или Close Fit (зависит от типа проекта и сцены).
        •        Shadow Distance: Максимальное расстояние, на котором будут видны тени.
        •        Shadow Cascades: Количество каскадов теней. Обычно используется 2 или 4 для более плавного перехода теней на большом расстоянии.


58 Какой компонент отвечает за обработку 2D объекта физическим движком?
В Unity есть два отдельных физических движка, один для 3D физики и один для 2D физики. Основные понятия идентичны в обоих движках (за исключением дополнительного измерения в 3D), но они реализованы с разными компонентами. Так, например, существует компонент Rigidbody для 3D физики и аналогичный Rigidbody 2D для 2D физики.
59 Как называются структуры, используемые для определения позиции, скорости или ускорения движения игрового объекта?
Хз, наверное речь реально про Vector (ответ также GPT)
В Unity структуры, используемые для определения позиции, скорости или ускорения движения игрового объекта, называются Vector3 и Vector2.
        1.        Vector3 - это структура, которая представляет вектор в трехмерном пространстве. Она используется для определения позиции, скорости и ускорения объектов в трехмерных играх.
      2.        Vector2 - это структура, которая представляет вектор в двумерном пространстве. Она используется для определения позиции, скорости и ускорения объектов в двухмерных играх. 


60 Что такое ParticleSystem?
Система частиц
Компонент Particle System имитирует жидкие субстанции наподобие разных жидкостей, облаков и чего-нибудь связанного с огнём путём генерации и анимации в сцене большого количества небольших 2D изображений.
Свойства
Компонент Particle System имеет множество настроек и для удобства, инспектор упорядочивает их в сворачиваемые секции или “модули” описываемые ниже. Каждая секция может быть развёрнута и свёрнута при нажатии на заголовок. С левой стороны расположены чекбоксы, которые можно отмечать для включения или отключения тех или иных настроек. Например, если вы не хотите менять размер частиц во время их излучения, вы можете просто снять галочку с параметра Size over lifetime.
  

Помимо модулей, в инспекторе есть ещё несколько других элементов управления. Кнопка Open Editor отображает опции в отдельном окне редактора, которое также позволяет вам редактировать одновременно несколько систем. А чекбокс Resimulate отвечает за то, будут или не будут тут же применяться изменения свойств к только что созданным системой частицам (в качестве альтернативы существующие частицы будут исчезать, так как они будут единственными новыми частицами, свойства которых были изменены). Кнопка Wireframe отображает контуры меш объектов, чтобы показать находящиеся за ними частицы.
61 Какой компонент отвечает за поведение системы частиц?
В Unity за поведение системы частиц отвечает компонент Particle System. Этот компонент позволяет создавать и настраивать различные эффекты частиц, такие как дым, огонь, взрывы и другие визуальные эффекты.
62 Какой класс отвечает за ввод данных пользователем с клавиатуры или другого устройства ввода?
Вопрос уже был. Но используется класс Input.
63 За что отвечает меню Console?


В Unity меню Console отвечает за отображение сообщений, предупреждений и ошибок, которые происходят во время работы редактора и выполнения игры. Оно является важным инструментом для отладки и диагностики в процессе разработки. В меню Console вы можете увидеть:


      * Логи сообщений (Logs): Информация о различных событиях, которые разработчик может выводить с помощью команды Debug.Log.
      * Предупреждения (Warnings): Сообщения о потенциальных проблемах, которые не являются критическими, но могут потребовать внимания. Они выводятся с помощью команды Debug.LogWarning.
      * Ошибки (Errors): Сообщения об ошибках, которые могут остановить выполнение кода или вызвать неправильное поведение. Ошибки выводятся с помощью команды Debug.LogError.


64 Что такое Asset Store и для чего он служит?
Asset Store в Unity — это онлайн-магазин, где разработчики могут приобретать и продавать различные ресурсы для своих проектов. Он служит для следующего:


      * Приобретение готовых ассетов: Разработчики могут покупать или скачивать бесплатные ассеты, такие как модели, текстуры, звуки, анимации, скрипты, шейдеры и многое другое. Это помогает сэкономить время и усилия, так как не нужно создавать все с нуля.


      * Продажа ассетов: Создатели контента могут продавать свои собственные ассеты другим разработчикам, зарабатывая деньги на своих навыках и трудах.


      * Ускорение разработки: Использование готовых ассетов позволяет быстро прототипировать и разрабатывать проекты, что особенно полезно для небольших команд или инди-разработчиков.




65 Без чего пользовательский интерфейс (UI) не будет корректно работать?
Для корректной работы пользовательского интерфейса (UI) в Unity необходимо наличие нескольких ключевых компонентов и элементов. Вот основные из них:


      * Canvas (Канвас): Основной компонент для всех UI-элементов. Он определяет область, в которой будут отображаться UI-элементы. Без Canvas UI-элементы не будут рендериться на экране.
      * Event System (Система событий): Этот компонент отвечает за обработку ввода и взаимодействие с UI-элементами. Без Event System кнопки, слайдеры и другие интерактивные элементы не будут реагировать на действия пользователя.
66 Интерфейс приложения.


Интерфейс приложения (User Interface, UI) в Unity включает в себя различные элементы, такие как кнопки, текст, изображения, панели и другие интерактивные компоненты. Чтобы создать эффективный и функциональный интерфейс приложения в Unity, необходимо понимать основные компоненты и их настройку. Рассмотрим основные шаги и элементы, необходимые для создания интерфейса приложения.


Основные компоненты UI в Unity
      * Canvas (Канвас): Описание: Это основной контейнер для всех UI-элементов. Он определяет область, в которой будут отображаться UI-элементы.
      * Event System (Система событий): Описание: Этот компонент управляет вводом и взаимодействием с UI-элементами. Основные компоненты: Event System, Standalone Input Module (или другой Input Module).
      * UI Elements (UI-элементы):
      * Button (Кнопка): Для взаимодействия пользователя с интерфейсом.
      * Text (Текст): Для отображения текста.
      * Image (Изображение): Для отображения изображений.
      * Slider (Слайдер): Для выбора значения из диапазона.
      * Toggle (Переключатель): Для включения или выключения состояния.
      * Input Field (Поле ввода): Для ввода текста пользователем.
      * Dropdown (Выпадающий список): Для выбора одного значения из нескольких.
67 Принципы взаимодействия компонентов движка.


В Unity взаимодействие компонентов движка основывается на нескольких ключевых принципах и архитектурных паттернах. Эти принципы обеспечивают гибкость, модульность и простоту разработки. Рассмотрим основные из них:
Компонентно-ориентированная архитектура
      * Unity использует компонентно-ориентированный подход, где каждый объект в сцене (GameObject) состоит из набора компонентов, которые определяют его поведение и характеристики.
      * GameObject: Основная сущность в Unity, представляющая любой объект на сцене.
      * Component: Скрипт или функциональный блок, который добавляется к GameObject, чтобы определить его поведение. Компоненты включают Transform, Renderer, Collider, Rigidbody и другие.
68 Роль материалов и шейдеров при рендеринге изображения.
Материалы и шейдеры играют ключевую роль в процессе рендеринга изображения в Unity, определяя, как объекты сцены будут выглядеть на экране. Они тесно связаны между собой и работают вместе, чтобы создать визуальный вид поверхности объектов.
Материал в Unity — это объект, который объединяет шейдер с его параметрами. Он определяет, какой шейдер использовать для рендеринга объекта и какие параметры применяются к этому шейдеру.
Шейдер — это программа, выполняемая на GPU, которая определяет, как вычисляются цвета и другие атрибуты пикселей или вершин.


69 Изменение свойств материалов со встроенными шейдерами.
В Unity изменение свойств материалов, использующих встроенные шейдеры, можно осуществить с помощью скриптов на C#. Это позволяет динамически изменять внешний вид объектов в сцене. Рассмотрим, как изменить свойства материалов, используя встроенные шейдеры.
Встроенные шейдеры в Unity включают Standard Shader, Unlit Shader, Particle Shader и другие. Каждый из них имеет свои параметры, которые можно изменять.
Для изменения свойств материала через скрипт нужно получить доступ к компоненту Renderer объекта, затем к его материалу, и изменить необходимые свойства.
Пример изменения шейдера металла и гладкости.
        
using UnityEngine;


public class ChangeMaterialProperties : MonoBehaviour
{
   public float newMetallic = 0.5f;
   public float newGlossiness = 0.5f;


   void Start()
   {
       // Получаем доступ к компоненту Renderer
       Renderer renderer = GetComponent<Renderer>();


       // Проверяем, есть ли у объекта Renderer
       if (renderer != null)
       {
           // Изменяем металличность материала
           renderer.material.SetFloat("_Metallic", newMetallic);


           // Изменяем гладкость материала
           renderer.material.SetFloat("_Glossiness", newGlossiness);
       }
   }
}


70 Коллайдеры.
Коллайдеры (Colliders) в Unity — это компоненты, которые добавляют физическое тело объектам в сцене, позволяя им участвовать в физических взаимодействиях, таких как столкновения и триггеры. Коллайдеры определяют форму объектов для этих взаимодействий, но сами по себе не имеют физики (например, массы и скорости) — для этого нужен компонент Rigidbody.
71 Физика тканей.
Физика тканей (Cloth Physics) в Unity позволяет создавать реалистичные симуляции текстильных материалов, таких как одежда, флаги, занавеси и другие. Этот функционал позволяет объектам в сцене реагировать на физические воздействия, такие как гравитация, коллизии и силы ветра.
Основные компоненты физики тканей в Unity:
      * Cloth Component (Компонент Ткани):Основной компонент, добавляемый к объекту для моделирования физики ткани.Он определяет форму и свойства ткани, такие как жесткость, сила и демпфирование.
      * Mesh Collider (Коллайдер сетки): Обычно используется для обеспечения столкновений объекта ткани с другими объектами в сцене.Может быть автоматически сгенерирован или создан вручную для более точного определения коллизий.
      * Cloth Renderer (Отрисовщик ткани):Отвечает за отображение ткани в игровом мире.Используется для отображения объекта ткани в режиме реального времени с учетом физических изменений.
Основные свойства Cloth Component:
      * Жесткость (Stiffness):Определяет степень жесткости ткани. Более высокое значение делает ткань менее подвижной.
      * Масса (Mass): Определяет массу ткани. Влияет на то, как ткань будет реагировать на физические силы.
      * Сопротивление воздуха (Drag): Определяет силу сопротивления воздуха, влияющую на скорость изменения движения ткани.
      * Сопротивление (Damping): Определяет уровень сопротивления движению ткани.
      * Поведение ветра (Wind Behavior):Управляет воздействием ветра на ткань.




72 Физические материалы.
Физический материал (Physics Material)


Physics Material используется для настройки эффектов трения и отскакивания объектов при столкновениях.


Чтобы создать физический материал (Physics Material) выберите из меню Assets->Create->Physics Material. Затем перетащите физический материал из окна Project View в Collider, находящийся в сцене.
  

Описание свойств материала


Свойство:
	Функция:
	Dynamic Friction
	Трение во время движения. Принимает значения в диапазоне от 0 до 1, где 0 соответствует слабому трению (как на льду), а 1 означает сильное трение, при котором объекту будет сложно двигаться без воздействия внешних сил.
	Static Friction
	Трение использующееся когда объект лежит на поверхности. Обычно значения бывают в диапазоне от 0 до 1. Значение равное 0 означает отсутствие трения, в то время как значение равное 1 будет означать абсолютное трение (т.е. объектам по такой поверхности будет сложно передвигаться).
	Bounciness
	How bouncy is the surface? A value of 0 will not bounce. A value of 1 will bounce without any loss of energy, certain approximations are to be expected though that might add small amounts of energy to the simulation.
	Friction Combine
	Как комбинируется между собой трение двух объектов.
	- Average
	Значения 2 трений усредняются.
	- Minimum
	Из двух значений используется то, что меньше.
	- Maximum
	Из двух значений используется то, что больше.
	- Multiply
	Значения трений умножаются друг на друга.
	Bounce Combine
	Как комбинируется упругость двух сталкивающихся объектов. Она поддерживает те же режимы, что и Friction Combine режим.
	



73 Параметры импорта трехмерных моделей.
Дока:
В инспекторе свойств импорта моделей есть три вкладки - Model, Rig и Animations.
      * Вкладка Model содержит настройки для импорта 3D модели.
      * Вкладка Rig содержит настройки, позволяющие текущей 3D модели поддерживать анимацию.
      * Вкладка Animations содержит настройки для импорта одного или нескольких анимационных клипов, содержащихся в файле с 3D моделью.
ГПТ (самое важное):
Перед импортом трёхмерной модели в Unity, убедитесь, что модель сохранена в одном из поддерживаемых форматов. Наиболее распространенные форматы:
      * FBX (.fbx)
      * OBJ (.obj)
      * Collada (.dae)
      * Blender (.blend)
Переместите файл модели в проект:
      * Откройте ваш проект в Unity.
      * Найдите папку Assets в окне проекта.
      * Перетащите файл модели из вашего файлового менеджера в папку Assets.
Импорт модели:
      * Unity автоматически распознает файл и начнет процесс импорта.
      * Модель появится в папке Assets в Unity.
74 Параметры импорта текстур.


ГПТ (посмотрел, хороший ответ, идёт по доке)
Шаги для импорта текстур:
      1. Подготовьте текстуры: Убедитесь, что ваши текстуры имеют правильный формат (например, PNG, JPEG, TIFF, BMP, TGA, PSD и т.д.).
      2. Импорт в Unity:
      * Перетащите файл: Перетащите файл текстуры из проводника или Finder в папку Assets в Unity.
      * Импорт через меню: Выберите Assets -> Import New Asset и выберите файл текстуры.
Параметры импорта текстур:
После импорта текстуры, выделите её в папке Assets, чтобы увидеть настройки в инспекторе. Основные параметры импорта текстур включают:
      1. Texture Type (Тип текстуры):
      * Default: Подходит для большинства текстур, используемых в 3D объектах.
      * Sprite (2D and UI): Используется для 2D игр и интерфейсов.
      * Normal map: Используется для карт нормалей.
      * Editor GUI and Legacy GUI: Для текстур, используемых в интерфейсе редактора.
      * Cubemap: Для кубических карт (обычно для отражений).
      * Lightmap: Для карт освещения.
      * Single Channel: Для текстур, использующих только один канал (например, для карт высот).
      2. Texture Shape (Форма текстуры)
      3. Wrap Mode (Режим обёртывания):
      * Repeat: Текстура повторяется
      * Clamp: Текстура ограничена краями
      * Mirror: Текстура зеркально отражается
      * Mirror Once: Текстура зеркально отражается один раз, затем обрезается
      4. Filter Mode (Фильтрация)
      5. Aniso Level (Анизотропная фильтрация)
      6. Mip Maps (Мип-карты)
      7. Max Size (Максимальный размер)
      8. Compression (Сжатие)
      9. SRGB (Color Texture)
      10. Alpha Source (Источник альфа-канала)
      11. Alpha Is Transparency (Определяет, считается ли альфа-канал как прозрачность)
      12. Read/Write Enabled (Разрешает доступ к текстуре на чтение и запись из скриптов)
75 Параметры импорта аудиофайлов.


Вы можете импортировать аудиофайлы в Unity, перетаскивая их прямо в окно проекта или используя меню Assets > Import New Asset. Unity поддерживает различные форматы аудиофайлов, такие как WAV, MP3, Ogg Vorbis и AIFF.


Основные параметры импорта аудиофайлов в Unity:
      1. Load Type (Тип загрузки):
      * Decompress on Load: Аудиофайл декодируется и хранится в памяти в некомпрессированном виде. Это уменьшает время загрузки, но требует больше оперативной памяти.
      * Compressed in Memory: Аудиофайл хранится в памяти в сжатом виде и декодируется при воспроизведении. Это уменьшает использование оперативной памяти, но может увеличивать нагрузку на процессор.
      * Streaming: Аудиофайл считывается с диска в реальном времени. Используется для длинных аудиотреков, таких как музыка или фоновые звуки.
      2. Compression Format (Формат сжатия):
      * PCM: Без сжатия, используется для высококачественного звука. Требует больше места в памяти.
      * ADPCM: Хороший компромисс между качеством звука и размером файла.
      * Vorbis: Высокое качество сжатия, хорошо подходит для музыки и фоновых звуков.
      * MP3: Популярный формат сжатия, хорошо подходит для музыки и фоновых звуков.
      3. Quality (Качество): Параметр качества применяется к формату сжатия 
      4. Sample Rate Setting (Настройка частоты дискретизации):
      * Preserve Sample Rate: Сохраняет исходную частоту дискретизации аудиофайла.
      * Optimize Sample Rate: Unity автоматически оптимизирует частоту дискретизации для уменьшения размера файла и повышения производительности.
      5. Load in Background (Загрузка в фоновом режиме): Позволяет загружать аудиофайл в фоновом режиме, чтобы не блокировать основной поток выполнения игры.
      6. Preload Audio Data (Предварительная загрузка аудиоданных): Если этот параметр включен, аудиофайл загружается в память при запуске игры. Если выключен, аудиофайл загружается только при необходимости.
      7. Force to Mono (Принудительное преобразование в моно): Преобразует стереофонические аудиофайлы в моно, что может уменьшить размер файла и повысить производительность.
      8. Normalize (Нормализация): Выравнивает уровни громкости аудиофайлов.
76 Системы поиска пути. Иерархия объектов, особенности, свойства.


В Unity для поиска пути обычно используются два основных подхода: NavMesh (навигационная сетка) и собственные алгоритмы поиска пути, такие как A* и Dijkstra.


NavMesh (Navigation Mesh) - это одна из самых распространенных систем поиска пути в Unity. Она позволяет агентам (персонажам, NPC и т.д.) находить путь по сложной поверхности.
Иерархия объектов
      1. NavMeshSurface: Компонент, который определяет область, на которой будет генерироваться NavMesh. Он прикрепляется к объекту сцены и задает параметры генерации сетки.
      2. NavMeshAgent: Компонент, прикрепляемый к объекту, который должен перемещаться по NavMesh. Этот компонент управляет движением объекта по сгенерированной сетке.
      3. NavMeshObstacle: Компонент, который определяет препятствия для NavMeshAgent. Он используется для динамических объектов, которые могут блокировать путь.
Особенности
      * Автоматическая генерация NavMesh: Unity может автоматически генерировать NavMesh для заданных поверхностей.
      * Динамическое обновление: NavMesh можно обновлять в реальном времени, чтобы учитывать изменяющиеся условия окружения.
Свойства
      * Agent Radius: Радиус агента, используемый для определения доступных путей.
      * Agent Height: Высота агента, учитывается при определении проходимых областей.
      * Max Slope: Максимальный угол наклона поверхности, по которой агент может пройти.
      * Step Height: Максимальная высота ступеньки, которую агент может преодолеть.
      * Speed: Скорость движения агента.
      * Angular Speed: Скорость поворота агента.
A* и Собственные Алгоритмы Поиска Пути
Unity также позволяет реализовать собственные алгоритмы поиска пути, такие как A* и Dijkstra. Эти алгоритмы могут использоваться в тех случаях, когда NavMesh недостаточен или требуется более специфическое поведение.
Иерархия объектов
      1. Grid или Graph: Сетка или граф, представляющий пространство для поиска пути. Может быть реализован в виде 2D или 3D массива, списка узлов и т.д.
      2. Node: Узел сетки или графа, представляющий конкретную точку в пространстве.
      3. Pathfinder: Скрипт, реализующий алгоритм поиска пути (например, A*). Этот компонент управляет процессом нахождения пути между начальной и конечной точками.
Особенности
      * Гибкость: Возможность настройки под специфические требования игры.
      * Точность: Возможность точного контроля за процессом поиска пути.
Свойства
      * Nodes: Список узлов (вершин графа), представляющих пространство.
      * Edges: Ребра графа, определяющие возможные пути между узлами.
      * Heuristic Function: Эвристическая функция для оценки стоимости пути (например, манхэттенское или евклидово расстояние).
      * Cost Function: Функция оценки стоимости перемещения между узлами.
      * Open List: Список узлов, которые еще не были проверены.
      * Closed List: Список узлов, которые уже были проверены.
77 Сцены в Unity, особенности, свойства, взаимодействие.
Сцены — это место, где вы работаете с контентом в Unity. Это активы, которые содержат всю игру или приложение или его часть. Например, вы можете построить простую игру в одной сцене, а для более сложной игры вы можете использовать одну сцену на уровне, каждая со своим окружением, персонажами, препятствиями, украшениями и UI. Вы можете создать любое количество сцен в проекте.


Диалоговое окно «Новая сцена» открывается, когда вы создаете новую сцену из меню «Файл»: (Файл > Новая сцена) или Ctrl/Cmd + n ярлык. Используйте его для создания новых сцен из определенных шаблонов сцен в вашем проекте и получения информации о существующих шаблонах.


      1. Поле поиска: поиск доступных шаблонов сцен по названию.
      2. Шаблоны: список всех доступных шаблонов в проекте.
      3. Сведения о шаблоне: отображает информацию о выбранном в данный момент шаблоне.
      4. Панель команд: содержит команды и параметры для создания новой сцены из выбранного шаблона.
Закрепленные шаблоны отображаются перед другими шаблонами в списке шаблонов диалогового окна "Новая сцена". Последний закрепленный шаблон отображается вверху списка.
Нажмите значок закрепления любого шаблона, чтобы закрепить его.
При выборе шаблона в диалоговом окне "Новая сцена" в области сведений отображается путь к шаблону.
Чтобы выделить шаблон в окне проекта, выберите ссылку Найти
Чтобы открыть шаблон в окне Инспектора и отредактировать его свойства, выберите ссылку Изменить.


78 Для чего нужен метод Awake?


Метод Awake в Unity используется для инициализации скриптов и объектов перед тем, как начнется выполнение игры. Он вызывается один раз при создании экземпляра объекта и происходит перед вызовом метода Start. Awake полезен для выполнения таких задач, как:
      1. Инициализация данных и переменных: Например, установка начальных значений переменных или настройка компонентов объекта.
      2. Поиск и установка ссылок на другие объекты и компоненты: Вы можете использовать Awake для поиска и сохранения ссылок на другие объекты в сцене, что может быть необходимо для дальнейшего взаимодействия.
      3. Настройка объекта перед его использованием: Если вам нужно выполнить какие-либо действия с объектом перед тем, как он начнет взаимодействовать с другими объектами или получать пользовательский ввод.
Основные особенности метода Awake:
      * Вызов перед методом Start: Awake вызывается до Start, что позволяет подготовить объект к дальнейшей работе.
      * Вызов вне зависимости от активации объекта: Awake вызывается даже если объект не активен в момент инициализации.
      * Отличие от метода Start: В отличие от Start, который может быть вызван после Awake, Awake вызывается немедленно после создания объекта и полезен для задач, которые должны быть выполнены в самом начале, до выполнения любых других методов.
  



79 Для чего нужен метод LateUpdate


Метод LateUpdate в Unity вызывается каждый кадр после метода Update. Он полезен для выполнения действий, которые должны происходить после всех обновлений состояния объектов сцены за текущий кадр. Основные случаи, когда LateUpdate полезен:
      1. Синхронизация с движением камеры: Если вам нужно, чтобы объект (например, камера) следовал за другим объектом и вы хотите, чтобы это происходило после того, как объект обновит свое положение в Update, LateUpdate будет идеальным местом для этого.
      2. Обновление объектов после выполнения всех логических операций: Если необходимо обновить состояние объектов на основе результатов всех предыдущих обновлений за кадр, LateUpdate предоставляет такую возможность.
      3. Корректировка объектов после выполнения физики: Например, если физическое обновление в FixedUpdate изменяет объект, и вам нужно внести изменения после этого, LateUpdate может быть использован для этих целей.
Основные особенности метода LateUpdate:
      * Вызов после Update: LateUpdate вызывается после того, как все Update методы всех объектов были вызваны.
      * Частота вызова: LateUpdate вызывается с той же частотой, что и Update, то есть каждый кадр.
  



80 Статический и динамический батчинг.


Статическая группировка - это метод группирования вызовов отрисовки, который объединяет сетки, которые не перемещаются, чтобы уменьшить количество вызовов отрисовки. Он преобразует объединенные сетки в мировое пространство и создает для них одну общую вершину и индексный буфер. Затем Unity выполняет один вызов отрисовки, который использует эту комбинированную сетку для отрисовки всех объектов в пакете одновременно. Статическая обработка
может значительно сократить количество вызовов отрисовки.


Статическая обработка более эффективна, чем динамическая
, поскольку при статической обработке вершины не преобразуются в процессоре.


Динамическая группировка - это метод группирования вызовов отрисовки, который группирует движущиеся игровые объекты
, чтобы сократить количество вызовов отрисовки. Динамическая группировка
работает по-разному в сетках и геометриях, которые Unity динамически генерирует во время выполнения, например в системах частиц
. Дополнительные сведения о внутренних различиях между сетками и динамическими геометриями см. в разделах Динамическое группирование для сеток и динамическое группирование для динамически генерируемых геометрий.


Примечание: Динамическая обработка пакетов для сеток была разработана для оптимизации производительности на старых недорогих устройствах. На современном потребительском оборудовании нагрузка на центральный процессор при динамической обработке пакетов может превышать затраты на вызов draw. Это отрицательно сказывается на производительности. Дополнительные сведения см. в разделе Динамическое группирование для сеток.


81 Определение понятия "виртуальная реальность" (VR).


Виртуальная реальность (VR) — это технология, которая создает полностью искусственную, трехмерную, интерактивную среду, в которую пользователь может погрузиться и взаимодействовать с ней. В отличие от дополненной реальности (AR), которая накладывает цифровые элементы на реальный мир, VR полностью заменяет реальный мир смоделированной средой.


82 Определение понятия "дополненная реальность" (АR).


Дополненная реальность (AR) — это технология, которая накладывает цифровую информацию и объекты на реальный мир, улучшая его восприятие и взаимодействие. В отличие от виртуальной реальности (VR), которая создает полностью искусственную среду, AR добавляет виртуальные элементы в существующую реальность.
83 Основные понятия виртуальной реальности.


Виртуальная реальность (VR) — это компьютерно-смоделированная среда, которая может имитировать физическое присутствие в реальном или вымышленном мире. Виртуальная реальность используется для различных целей, включая развлечения, образование, медицину, архитектуру и т. д. Вот основные понятия, связанные с виртуальной реальностью:
      1. Виртуальная реальность (VR):
      * Это имитация реальности, созданная с помощью компьютерных технологий, которая позволяет пользователю погрузиться в цифровую среду.
      2. Дополненная реальность (AR):
      * Это технология, которая накладывает цифровые элементы на реальный мир через устройства, такие как смартфоны или очки дополненной реальности.
      3. Миксированная реальность (MR):
      * Это сочетание виртуальной и дополненной реальности, где виртуальные объекты могут взаимодействовать с реальным миром в реальном времени.
      4. Очки виртуальной реальности (HMD):
      * Специальные устройства, надеваемые на голову, которые закрывают глаза и показывают пользователю виртуальную среду. Примеры: Oculus Rift, HTC Vive, PlayStation VR.
      5. Контроллеры движения:
      * Устройства, которые позволяют пользователю взаимодействовать с виртуальной средой через физические движения. Примеры: контроллеры Oculus Touch, контроллеры Vive.
      6. Трекеры:
      * Устройства, которые отслеживают движение пользователя или объектов в реальном пространстве и переводят эти данные в виртуальную среду.
      7. Пространственное аудио:
      * Технология, которая создает трехмерный звуковой опыт, чтобы пользователь мог слышать звуки в виртуальной среде так, как если бы они исходили из определенных направлений.
      8. Гаптическая обратная связь:
      * Технология, которая обеспечивает тактильную обратную связь, позволяя пользователю ощущать прикосновения и взаимодействия в виртуальной среде.
      9. Латентность:
      * Задержка между действием пользователя и реакцией системы VR. Низкая латентность важна для обеспечения реалистичного и комфортного опыта.
      10. Поле зрения (FOV):
      * Угол, под которым пользователь может видеть виртуальную среду. Широкое поле зрения улучшает погружение.




84 Аппаратные средства виртуальной реальности.


Аппаратные средства виртуальной реальности (VR) включают в себя разнообразные устройства и технологии, которые позволяют пользователям погружаться в виртуальные миры. Вот основные компоненты, которые используются в системах виртуальной реальности:
      1. Шлемы виртуальной реальности (HMD, Head-Mounted Display):
      * Oculus Rift/Quest: Один из самых популярных шлемов VR, предлагающий высокое разрешение и точное отслеживание движений.
      * HTC Vive: Известен своими точными контроллерами и комнатным отслеживанием.
      * PlayStation VR: Используется в основном с консолями PlayStation.
      * Valve Index: Обеспечивает высокое разрешение, частоту обновления и улучшенные контроллеры.
      2. Контроллеры:
      * Motion Controllers: Такие как контроллеры Oculus Touch, HTC Vive Controllers и Valve Index Controllers, которые позволяют пользователям взаимодействовать с виртуальными объектами.
      * Gamepads: Традиционные игровые контроллеры, используемые в некоторых VR-системах.
      * Перчатки для VR: Такие как Manus VR, которые обеспечивают тактильную обратную связь и более точное отслеживание движений пальцев.
      3. Сенсоры и камеры:
      * Внешние сенсоры: Например, базовые станции HTC Vive и камеры PlayStation VR, которые отслеживают положение шлема и контроллеров.
      * Встроенные сенсоры: Некоторые шлемы, такие как Oculus Quest, имеют встроенные камеры и сенсоры для отслеживания движений без необходимости в дополнительных внешних устройствах.
      4. Компьютеры и консоли:
      * Мощные настольные компьютеры и ноутбуки, оснащенные высокопроизводительными видеокартами (например, NVIDIA GeForce RTX или AMD Radeon).
      * Консоли, такие как PlayStation 4/5 для PlayStation VR.
      5. Аксессуары:
      * Тактильные жилеты и костюмы: Такие как Teslasuit, которые обеспечивают тактильную обратную связь по всему телу.
      * Беговые дорожки для VR: Например, Virtuix Omni, которые позволяют пользователям перемещаться в виртуальном пространстве естественным образом.
      * Аудио устройства: Высококачественные наушники и звуковые системы для создания пространственного звука и улучшенного погружения.
      6. Мобильные VR устройства:
      * Google Cardboard: Простое и доступное решение для погружения в VR с помощью смартфона.
      * Samsung Gear VR: Мобильная VR-гарнитура, работающая со смартфонами Samsung.
85 Обзор и сравнение современных 3D-движков. Возможности, условия использования.


Современные 3D-движки предоставляют мощные инструменты для разработки игр, анимаций, симуляций и других интерактивных приложений. Рассмотрим основные из них: Unity, Unreal Engine, Godot и CryEngine, сравнив их возможности и условия использования.
1. Unity
Возможности:
      * Кроссплатформенность: Поддержка более 25 платформ, включая ПК, мобильные устройства, консоли, VR и AR.
      * Гибкость: Поддержка C# для скриптинга, большой выбор готовых ассетов и инструментов.
      * Физика и анимация: Встроенные физические движки (PhysX, Havok), мощные инструменты для анимации и кинематики.
      * Сеть и многопользовательские игры: Плагины и встроенные инструменты для создания сетевых игр.
      * Дополненная и виртуальная реальность: Широкая поддержка VR и AR.
Условия использования:
      * Бесплатная версия: Unity Personal для индивидуальных разработчиков и небольших студий.
      * Платная версия: Unity Plus, Unity Pro, Unity Enterprise с расширенными функциями и поддержкой.
      * Лицензионные ограничения: Бесплатная версия для дохода до $100,000 в год. Платные версии предлагают больше возможностей и ресурсов.
2. Unreal Engine
Возможности:
      * Высококачественная графика: Поддержка фотореалистичной графики, мощный рендеринг и визуализация.
      * Скриптинг: Использование как C++, так и визуального скриптинга (Blueprints).
      * Анимация и физика: Встроенные инструменты для создания сложных анимаций и симуляций.
      * Многопользовательские игры: Встроенные инструменты для сетевых игр и серверных решений.
      * Кроссплатформенность: Поддержка множества платформ, включая VR и AR.
Условия использования:
      * Бесплатная версия: Бесплатная до момента коммерческого использования.
      * Лицензия: 5% роялти с доходов свыше $1,000,000.
      * Коммерческое использование: Плата роялти с дохода, но бесплатное использование для личных проектов и некоммерческого использования.
3. Godot
Возможности:
      * Открытый исходный код: Полностью бесплатный и открытый.
      * Скриптинг: Использование собственного языка GDScript, а также C#, VisualScript и других языков.
      * Модульность: Легко настраиваемая архитектура, поддержка 2D и 3D проектов.
      * Кроссплатформенность: Поддержка основных платформ, включая ПК, мобильные устройства и веб.
Условия использования:
      * Бесплатный: Полностью бесплатен и не требует лицензионных отчислений.
      * Открытый исходный код: Разработка и модификация исходного кода.


86 Навигация в виртуальном пространстве игровой сцены. 


Навигация в виртуальной реальности (VR) — это процесс перемещения и взаимодействия с виртуальной средой. Существует несколько методов навигации в VR, которые можно разделить на следующие категории:
1. Физическое перемещение
Это естественное движение пользователя в реальном пространстве, которое переносится в виртуальную среду. Для этого используются:
      * Комнаты с трекингом: Пользователь перемещается в специально оборудованном пространстве, и его движения отслеживаются системой.
      * Маркеры и камеры: Специальные маркеры или камеры отслеживают движение пользователя и передают данные в VR-систему.
2. Телепортация
Один из самых популярных методов навигации, особенно для больших виртуальных пространств.
      * Точки назначения: Пользователь выбирает точку в виртуальном пространстве, куда хочет переместиться, и мгновенно телепортируется туда.
      * Маркеры на полу: Виртуальные метки на полу, к которым пользователь может телепортироваться.
3. Плавное перемещение
Пользователь перемещается в виртуальной среде аналогично перемещению в видеоиграх.
      * Джойстики или контроллеры: Использование контроллеров для перемещения вперед, назад и в стороны.
      * Беговые дорожки для VR: Специальные устройства, которые позволяют пользователю физически идти или бежать, оставаясь на месте, при этом его движения переносятся в виртуальную среду.
4. Управление жестами
Использование жестов рук и тела для навигации и взаимодействия с виртуальной средой.
      * Распознавание жестов: Системы, отслеживающие движения рук и пальцев для управления и навигации.
      * Контроллеры с сенсорами: Устройства, отслеживающие движения рук и передающие их в VR.
5. Голосовое управление
Использование голосовых команд для навигации и взаимодействия.
      * Голосовые команды: Команды типа "перейти в другую комнату", "приблизить объект" и т.д.
      * Ассистенты: Виртуальные ассистенты, которые понимают и выполняют голосовые команды.
6. Комбинированные методы
Комбинация различных методов навигации для повышения удобства и естественности взаимодействия.
      * Физическое перемещение и телепортация: Пользователь может физически перемещаться в ограниченном пространстве и телепортироваться на большие расстояния.
      * Голосовое управление и жесты: Пользователь может использовать голосовые команды для выполнения сложных действий и жесты для более простых.


87 Назначение и роль компонента NVIDIA PhysX.


NVIDIA PhysX - это программный компонент, который предназначен для симуляции физики в компьютерных играх, приложениях виртуальной реальности и других интерактивных средах. Его основное назначение и роль заключаются в создании реалистичной симуляции физических объектов, взаимодействия между ними и окружающей средой.
Вот основные назначение и роли компонента NVIDIA PhysX:
      1. Симуляция физики объектов: PhysX обеспечивает расчёт движения, коллизий, деформаций и других физических эффектов для объектов в виртуальной среде. Это включает в себя поведение твёрдых тел, жидкостей, мягких тканей, частиц и т.д.
      2. Реалистичное взаимодействие: PhysX обрабатывает взаимодействие между объектами и окружающей средой таким образом, чтобы оно выглядело естественно и реалистично. Например, объекты могут сталкиваться, падать, катиться, ломаться и взаимодействовать с другими объектами.
      3. Поддержка различных материалов и поверхностей: PhysX учитывает различные свойства материалов, такие как трение, упругость, масса и т.д., что позволяет создавать разнообразные поведения объектов.
      4. Использование в играх и симуляторах: Основное применение PhysX - в компьютерных играх и симуляторах, где реалистичная симуляция физики добавляет взаимодействие и иммерсивность.
      5. Улучшение визуального опыта: Физические эффекты, моделированные с помощью PhysX, способствуют улучшению визуального опыта пользователей, делая игровой мир более реалистичным.
      6. Вычисления на GPU: PhysX может использовать мощности графического процессора (GPU) для ускорения расчётов физики, что повышает производительность и позволяет обрабатывать более сложные сцены.
      7. Инструменты для разработчиков: NVIDIA предоставляет разработчикам набор инструментов для интеграции PhysX в игры и приложения, что упрощает создание реалистичной физики.
В целом, роль NVIDIA PhysX заключается в добавлении реалистичной симуляции физики в интерактивные приложения, что способствует созданию более увлекательного и иммерсивного пользовательского опыта.




88 Запекание карт освещения (Lightmaps).


Запекание карт освещения, или lightmapping, - это процесс создания текстурных карт, которые содержат информацию об освещении сцены. Эти карты затем применяются к объектам в сцене для имитации освещения, что позволяет создать более реалистичные эффекты освещения без необходимости рассчета освещения в реальном времени.
Вот общий процесс создания и применения lightmaps:
      1. Расчет освещения:
      * Сначала необходимо рассчитать освещение сцены. Это может быть выполнено с помощью различных методов, таких как ray tracing, radiosity, или методы подобные им. Результатом являются значения освещенности для каждой точки на поверхности объектов в сцене.
      2. Создание lightmaps:
      * После расчета освещения создаются текстуры, известные как lightmaps. Lightmaps содержат информацию об освещенности сцены.
      * Каждый пиксель lightmap'а представляет собой значение освещенности для соответствующей точки на поверхности объекта.
      3. Запекание (Применение) lightmaps:
      * После создания lightmaps они применяются к текстурам объектов в сцене.
      * Это может быть достигнуто различными способами, в зависимости от используемого движка или инструментов. Обычно это делается путем наложения lightmap'а на текстуру объекта в редакторе сцен или в процессе компиляции сцены.
      4. Отображение в реальном времени:
      * Во время рендеринга сцены в реальном времени, текстуры объектов уже содержат информацию об освещении из lightmaps.
      * Это позволяет достичь эффекта реалистичного освещения без необходимости проведения сложных расчетов в реальном времени.
Преимущества использования lightmaps включают улучшенную производительность за счёт снижения нагрузки на процессор и возможность создания более высококачественных эффектов освещения. Однако они также имеют некоторые ограничения, например, они не учитывают динамические изменения освещения.
89 Типы шейдеров: вершинные шейдеры, пиксельные шейдеры.


Шейдеры - это программы, которые работают на графических процессорах и используются для выполнения различных операций с графикой. Два основных типа шейдеров в компьютерной графике:
      1. Вершинные шейдеры (Vertex Shaders):
      * Назначение: Вершинные шейдеры работают с каждой вершиной (точкой) объекта в трехмерном пространстве.
      * Задачи: Они могут выполнять преобразования вершин, такие как перемещение, масштабирование, вращение и так далее. Также они могут применять освещение или цветовые эффекты к вершинам.
      * Пример использования: Преобразование трехмерных координат объекта в координаты экрана, применение освещения.
      2. Пиксельные шейдеры (Pixel Shaders, Fragment Shaders):
      * Назначение: Пиксельные шейдеры работают с каждым пикселем, который будет отображен на экране.
      * Задачи: Они определяют цвет каждого пикселя на основе различных параметров, таких как освещение, текстуры, тени, эффекты и т.д.
      * Пример использования: Применение текстур, расчет освещения, применение пост-эффектов (например, размытие, смешивание цветов).
Основное отличие между вершинными и пиксельными шейдерами заключается в том, на каком этапе они выполняются и что они обрабатывают:
      1. Вершинные шейдеры:
      * Что обрабатывают: Каждая вершина объекта.
      * Когда выполняются: На этапе вершинного процессора до растеризации.
      * Задачи: Основная задача - преобразование координат вершин объекта и применение операций, связанных с вершинами, таких как перемещение, масштабирование, поворот и применение освещения к вершинам.
      * Пример использования: Преобразование координат вершин, применение матриц преобразования, расчет освещения в каждой вершине.
      2. Пиксельные шейдеры (также называемые фрагментными шейдерами):
      * Что обрабатывают: Каждый пиксель, который будет отображен на экране.
      * Когда выполняются: После растеризации, когда геометрия уже преобразована в фрагменты (пиксели).
      * Задачи: Задача пиксельного шейдера - определить цвет каждого пикселя на основе различных параметров, таких как текстуры, освещение, тени, эффекты и другие данные, переданные из вершинного шейдера.
      * Пример использования: Применение текстур, расчет освещения, определение цвета пикселя.
90 Физика твердых тел (Rigidbody).


Rigidbody - это основной компонент, подключающий физическое поведение для объекта. С прикреплённым Rigidbody, объект немедленно начнёт реагировать на гравитацию. Если добавлен один или несколько компонентов Collider, то при коллизиях (столкновениях) объект будет передвигаться.


Так как компонент Rigidbody управляет перемещением объекта, к которому он прикреплён, вам не следует пытаться воздействовать на объект из кода с помощью изменения таких свойств Transform, как position и rotation. Вместо этого вам следует применять силы для того, чтобы толкать объект и позволить физическому движку рассчитать результаты.


Свойства (не все, лишь основные):


Mass
	Масса объекта (по умолчанию в килограммах).
	Drag
	Насколько сопротивление воздуха влияет на объект при движении от сил
	Use Gravity
	Если включено, на объект действует гравитация.
	Is Kinematic
	Если этот параметр включен, физический движок не будет управлять объектом, и им можно будет манипулировать только с помощью преобразования. Это полезно для движущихся платформ или если вы хотите анимировать Rigidbody, к которому прикреплено HingeJoint.
	None
	Интерполяция не применяется.
	Interpolate
	Преобразование сглаживается на основе преобразования предыдущего кадра.
	Extrapolate
	Преобразование сглаживается на основе предполагаемого преобразования следующего кадра.
	Collision Detection
	Используется для предотвращения прохождения быстро движущихся объектов через другие объекты без обнаружения столкновений
	Discrete
	Используйте дискретное обнаружение столкновений со всеми другими коллайдерами в Сцене. Другие коллайдеры будут использовать дискретное обнаружение столкновений при проверке на столкновение с ним. Используется для обычных столкновений (это значение по умолчанию).
	Freeze Position
	Выборочно останавливает твердое тело, перемещающееся по мировым осям X, Y и Z.
	Freeze Rotation
	Выборочно останавливает вращение Rigidbody вокруг локальных осей X, Y и Z.
	

91 Оптимизация скриптов.


Вы можете использовать встроенный профайлер для выяснения процесса, тормозящего вашу игру, будь то физика, скрипты, или отрисовка, но вы не сможете взглянуть на определённые скрипты и методы для поиска точного источника проблемы. Однако, добавив в вашу игру переключатели для включения или отключения того или иного функционала, вы сможете отследить самые проблемные участки. Например, если вы удалите скрипт AI для персонажей противника и при этом частота кадров возрастёт вдвое, вы поймёте, что следует оптимизировать этот скрипт, или что-то из того, что он привносит в игру. Основная проблема в том, что вам может потребоваться много попыток, прежде чем вы сможете обнаружить проблему.


Память выделяется каждый раз, когда создаётся объект. Зачастую в коде вы создаёте объекты даже не подозревая об этом.
      * Debug.Log("boo" + "hoo"); создаёт объект.
      * Используйте System.String.Empty вместо "" при работе с большим количеством строк.
      * OnGUI (UnityGUI) работает медленно и его не следует использовать в случаях, когда важна производительность.
      * Различия между классом и структурой:
Почему пулинг объектов быстрее
Дело в том, что частое использование Instantiate и Destroy подкидывает сборщику мусора прилично работы, что может привести к рывкам во время игры. Как рассказано на странице про автоматическое управление памятью, существуют другие способы обойти основные проблемы с производительностью, окружающие Instantiate и Destroy, такие как ручной запуск сборщика мусора пока на экране ничего не происходит, или очень частый его запуск для предотвращения накапливания большого количества работы для сборщика.
Кэшируйте ссылки вместо осуществления повторного поиска
Например, в вашей игре есть 100 врагов, и все они двигаются в сторону игрока.
Это может работать медленно, если среди них достаточно много бегущих одновременно. Небольшой известный факт: все поля для доступа к компонентам в MonoBehaviour, такие как transform, renderer, и audio, эквивалентны соответствующим вызовам GetComponent(Transform), и потому они работают немного медленно. Метод GameObject.FindWithTag был оптимизирован, но в некоторых случаях, например, во вложенных циклах, или в скриптах, которые запущены на большом количестве экземпляров, оно тоже может работать немного медленно.
Избегайте использования ресурсоёмких математических функций
Избегайте или минимизируйте O(n2) операции на больших наборах данных


92 Сетевая виртуальная реальность.


Виртуальная реальность (VR) переносит пользователей в окружение, полностью созданное компьютером, создавая иммерсивную и зачастую интерактивную атмосферу. Пользователь надевает гарнитуру, чтобы исследовать эту цифровую среду и взаимодействовать с ней.
Инструменты и библиотеки для разработки VR в Unity
1. XR Management
Unity предоставляет XR Management для управления различными VR SDK и упрощения настройки проекта для нескольких платформ.
2. Unity XR Interaction Toolkit
Набор инструментов для создания интерактивных VR-приложений, включающий готовые компоненты для взаимодействия с объектами, перемещения и анимации.
Сетевая виртуальная реальность (Networked Virtual Reality, NVR) представляет собой технологию, которая позволяет нескольким пользователям взаимодействовать и воспринимать один и тот же виртуальный мир в реальном времени через удаленные сети. 


Позиция и ориентация: Важно синхронизировать положение и поворот головы каждого пользователя, чтобы они видели других участников и объекты в правильных местах.
Взаимодействия: Синхронизация действий, таких как движения, жесты, переключение состояний объектов.


93 Освещение объектов с использованием шейдеров.


Шейдеры позволяют программировать процесс освещения и отображения объектов, что особенно полезно для создания специфических эффектов, таких как отражения, преломления света, симуляция погодных условий и многого другого. Вот несколько ключевых аспектов использования шейдеров для освещения в Unity:
      1. Типы шейдеров для освещения:
      * Surface Shaders: Упрощенный способ написания шейдеров, который автоматически управляет освещением, создавая поверхностные шейдеры с поддержкой освещения и теней.
      * Shader Graph: Визуальный графический интерфейс для создания шейдеров, позволяющий интуитивно создавать сложные эффекты освещения.
      2. Функции освещения в шейдерах:
      * Рассеянное освещение (Diffuse Lighting): Моделирует равномерное рассеянное освещение на поверхности объекта.
      * Зеркальное освещение (Specular Lighting): Эмулирует отражение и блики на поверхности в зависимости от направления источника света и положения камеры.
      * Преломление (Refraction): Имитация изменения направления света при прохождении через материалы с различными показателями преломления.
      * Отражения (Reflection): Создание отражений окружающей среды на поверхностях объектов.
      3. Настройка свойств шейдера:
      * Цвет и интенсивность освещения: Управление цветом и яркостью освещения.
      * Тени: Включение и настройка создания и бросания теней.
      * Прозрачность и преломление: Управление прозрачностью и эффектами преломления для создания стеклянных или прозрачных поверхностей.


94 Типы источников света.


Directional Light (Направленный свет):
      * Этот источник света моделирует параллельные лучи света, как если бы свет был бесконечно далеко, например, солнце.
      * Он освещает все объекты в сцене одинаково и используется для создания общего освещения или эффектов на открытых пространствах.
Point Light (Точечный свет):
      * Источник света, который излучает свет во все стороны из точки в пространстве.
      * Используется для создания эффекта освещения, исходящего от источника, находящегося в определенной точке, например, лампочки, факела и т.д.
Spotlight (Прожектор):
      * Источник света, который излучает конусообразный луч света с определенным углом.
      * Часто используется для создания эффекта направленного освещения, как у фонаря или прожектора.
Area Light (Поверхностный источник света):
      * Эмулирует освещение от большой поверхности, такой как окно или большой экран.
      * Позволяет создать более мягкие и реалистичные тени.
Light Probe (Источник света-зонда):
      * Используется для определения освещения в динамических сценах, где освещение меняется в зависимости от положения и точки обзора камеры.
      * Помогает поддерживать консистентное освещение и тени в различных частях сцены.
95 Создание интерактивного приложения без написания кода.
Полная залупа, что это за вопрос вообще, в интернетах только кринж, выручает любимый гпт
1. Unity Visual Scripting (Bolt)
Unity предлагает инструмент под названием Bolt, который позволяет создавать логику игры через визуальное программирование. Bolt представляет собой графический интерфейс, где вы можете создавать логику и взаимодействие без необходимости вручную писать код. Он интегрирован напрямую в Unity и предоставляет множество готовых блоков для создания сложных поведений.
2. Unity Asset Store
На Unity Asset Store можно найти множество готовых решений и плагинов, которые позволяют добавлять интерактивные элементы в проекты без необходимости программирования. Например, существуют плагины для создания интерфейсов, анимаций и простых взаимодействий, которые можно настроить через интерфейс Unity.
3. Playmaker
Playmaker — это еще один популярный инструмент для визуального программирования в Unity. Он предоставляет аналогичный Bolt интерфейс для создания игровой логики и поведений, используя состояния и события.
96 Создание и использование скриптов.
Скрипты - это основа для создания интерактивности в вашей игре, это то, что задает поведение объектам на сцене. 
Для создания скрипта необходимо в меню добавления компонента выбрать “New script” и задать название скрипта, юнити автоматически создаст скрипт с соответствующим названием класса. 
Все скрипты наследуются от MonoBehaviour - это базовый класс, который обеспечивает фундаментальную функциональность для всех скриптов, работающих в игровом движке. Он дает связь с игровыми компонентами, предоставляет методы жизненного цикла (Start, Update и тд)..


97 Функции событий.
Для понимания работы событий необходимо понимать, что такое делегаты. Делегат – это тип, который представляет ссылки на методы с определенным списком параметров и типом возвращаемого значения. При создании экземпляра делегата этот экземпляр можно связать с любым методом с совместимой сигнатурой и типом возвращаемого значения. Метод можно вызвать (активировать) с помощью экземпляра делегата. Делегаты используются для передачи методов в качестве аргументов к другим методам. Для объявления делегата используется ключевое слово delegate, после которого идут возвращаемый тип, название и параметры. В данном примере показано, что делегат присваивает себе ссылку на оба метода поочередно, так как у них одинаковая сигнатура.
Вот список с кучей функций событий из гпт:
* **`Start()`**: Вызывается один раз, когда объект с этим скриптом активируется. Используется для инициализации объекта, настройки переменных, запуска анимаций и т.д.
* **`Update()`**: Вызывается каждый кадр игры. Используется для обновления состояния объекта, обработки ввода, выполнения анимаций и т.д.
* **`FixedUpdate()`**: Вызывается с фиксированной частотой, независимо от FPS игры. Используется для обработки физики, так как физический движок требует постоянного обновления.
* **`LateUpdate()`**: Вызывается после `Update()`. Используется для задач, которые должны выполняться после обновления всех объектов.
* **`OnEnable()`**: Вызывается, когда объект становится активным.
* **`OnDisable()`**: Вызывается, когда объект становится неактивным.
* **`OnDestroy()`**: Вызывается непосредственно перед уничтожением объекта. Используется для очистки ресурсов, отмены подписок на события и т.д.


**Взаимодействие с пользователем:**


* **`OnMouseDown()`**: Вызывается, когда игрок кликает на объект левой кнопкой мыши.
* **`OnMouseUp()`**: Вызывается, когда игрок отпускает левую кнопку мыши.
* **`OnMouseEnter()`**: Вызывается, когда курсор мыши оказывается над объектом.
* **`OnMouseExit()`**: Вызывается, когда курсор мыши покидает объект.
* **`OnMouseOver()`**: Вызывается каждый кадр, пока курсор мыши находится над объектом.
* **`OnGUI()`**: Вызывается для рендеринга GUI-элементов.


**Коллизии:**


* **`OnCollisionEnter(Collision collision)`**: Вызывается, когда объект входит в коллизию с другим объектом.
* **`OnCollisionExit(Collision collision)`**: Вызывается, когда объект выходит из коллизии с другим объектом.
* **`OnCollisionStay(Collision collision)`**: Вызывается каждый кадр, пока объект находится в коллизии с другим объектом.
* **`OnTriggerEnter(Collider other)`**: Вызывается, когда объект входит в триггер-коллизию с другим объектом.
* **`OnTriggerExit(Collider other)`**: Вызывается, когда объект выходит из триггер-коллизии с другим объектом.
* **`OnTriggerStay(Collider other)`**: Вызывается каждый кадр, пока объект находится в триггер-коллизии с другим объектом.


**Другие:**


* **`OnAnimatorIK(int layerIndex)`**: Вызывается для обновления параметров анимации.
* **`OnAnimatorMove()`**: Вызывается после завершения анимации.
* **`OnValidate()`**: Вызывается, когда свойства объекта изменяются в инспекторе.
* **`OnParticleCollision(GameObject other)`**: Вызывается, когда частица системы частиц сталкивается с другим объектом.
* **`OnSerializeNetworkView(BitStream stream, NetworkMessageInfo info)`**: Используется для сетевой синхронизации объектов.
98 Создание и уничтожение игровых объектов (GameObjects).
В Unity существует несколько способов создания новых игровых объектов (GameObjects) в игре:
1. Использование редактора (через ui)
2. Использование скриптов:
        - Instantiate(): Создает экземпляр объекта, используя prefab или существующий GameObject.
- GameObject.CreatePrimitive():  Создает примитивные объекты, такие как куб, сфера, цилиндр и т.д.
Уничтожение объектов
1. Использование редактора(ui)
2. Использование скриптов:
   - Destroy(): Уничтожает объект после завершения текущего кадра.
   - DestroyImmediate(): Уничтожает объект немедленно.
При уничтожении объекта, все его дочерние объекты также будут уничтожены. Поэтому важно следить за порядком создания и уничтожения объектов в игре, чтобы избежать ошибок и утечек памяти.
99 Порядок выполнения функций событий.
При создании скрипта можно обратить внимание на методы класса, которые там есть. Эти методы класса являются сообщениями класса MonoBehaviour, 19 которые вызываются в определённом порядке. Далее разберем несколько стандартных сообщений, которые чаще всего используются при разработке проектов на движке Unity. Для лучшего понимания реализуем эти методы и посмотрим порядок их выполнения с помощью вывода текста в консоль. Выведем название метода при его исполнении. Как раз для этого в Unity есть специальный класс Debug, который позволяет заниматься отладкой в режиме исполнения.
  

Итоговый порядок 
  

Краткое описание каждого метода:
 − Awake – это метод, который вызывается единожды при “пробуждении” игрового объекта. 
− OnEnable – метод, который вызывается при включении игрового объекта. Отличие “пробуждения” и активность игрового объекта – будет разобрано дальше. 
− Start – метод, который вызывается единожды перед вызовом метода Update.
− Update – это метод, который вызывается каждый кадр игры и нужен для обновления состояния игры.
 − FixedUpdate – главное его отличие от Update, что этот метод не зависит от частоты кадров. Данный метод используется для просчёта физики.
 − LateUpdate – это метод, который вызывается после метода обновления игры (Update) 
− OnDisable – метод, который вызывается, когда игровой объект отключается, что это значит будет разобрано чуть дальше.
 − OnDestroy – метод, который вызывается при уничтожении объекта.


100 Компоненты взаимодействия
В Unity есть несколько компонентов, которые отвечают за взаимодействие между игровыми объектами, игроком и окружающей средой. Давайте рассмотрим наиболее распространенные из них:


1. Collider (Коллайдер)
Коллайдер - это невидимый компонент, который определяет форму и размер объекта для целей столкновений.
- Типы: 
    - Box Collider:  Простой прямоугольный Коллайдер.
    - Sphere Collider:  Сферический Коллайдер.
    - Capsule Collider:  Коллайдер в форме капсулы.
    - Mesh Collider:  Коллайдер, который точно соответствует форме меша объекта.
- Применение:  Коллайдеры используются для обнаружения столкновений между объектами, а также для взаимодействия с физическим движком.
- Пример:  Игровой персонаж имеет Коллайдер, чтобы не проходить сквозь стены.


2. Rigidbody (Жесткое тело)


- Что делает:  Rigidbody -  это компонент, который добавляет физику к объекту. 
- Применение:  Rigidbody позволяет объекту взаимодействовать с силой тяжести, силами и другими объектами, имеющими Rigidbody, благодаря физическому движку Unity.
- Пример:  Мяч, который отскакивает от стен, имеет Rigidbody.


3. Character Controller (Контроллер персонажа)


- Что делает:  Контроллер персонажа - это специализированный компонент, который используется для создания персонажей, способных перемещаться по сложной местности.
- Преимущества:  
    - Упрощает управление персонажем.
    - Обеспечивает плавное движение по пересеченной местности.
    - Предлагает функции,  удобные для создания персонажей (например, управление скоростью и прыжками).
- Пример:  Игрок, который может ходить, бегать и прыгать по земле, использует Character Controller.


4. Joint (Соединение)


- Что делает:  Соединения используются для связывания объектов друг с другом, создавая различные типы физических связей.
- Типы: 
    - Hinge Joint:  Позволяет объектам вращаться вокруг оси, как шарнир.
    - Spring Joint:  Создает пружинную связь между объектами.
    - Fixed Joint:  Соединяет объекты жестко.
    - Character Joint:  Специализированное соединение для управления персонажами.
- Пример:  Руки робота, которые могут вращаться,  используют Hinge Joint.


5. Trigger (Триггер)


- Что делает:  Триггер - это Коллайдер, который не вызывает физического отклика, а только сообщает о том, что объект вошел в его область.
- Применение:  Триггеры используются для запуска событий, например, когда игрок входит в определенную область или взаимодействует с объектом.
- Пример:  Область, которая запускает анимацию, когда игрок в нее входит.


6. Raycast (Лучевой запрос)


- Что делает:  Raycast - это инструмент для определения пересечения луча с объектами в сцене. 
- Применение:  Raycast используется для обнаружения объектов перед игроком, проверки на коллизию с препятствиями, определения расстояния до объекта и других задач, связанных с обнаружением объектов.
- Пример:  Игрок, который стреляет из оружия, может использовать Raycast для определения объекта, в который попала пуля.


Дополнительные компоненты:
• Animator:  Управление анимацией объектов.
• AudioSource:  Проигрывание звука.
• Canvas:  Создание пользовательского интерфейса.